- [Introduction](#introduction)
  - [1. 운영체제](#1-운영체제)
  - [2. 운영체제의 목적](#2-운영체제의-목적)
  - [3. 운영체제의 분류](#3-운영체제의-분류)
  - [4. Multiprocessor](#4-multiprocessor)
  - [5. 커널](#5-커널)
  - [6. 운영체제의 예](#6-운영체제의-예)
  - [7. 운영체제의 역할](#7-운영체제의-역할)
- [컴퓨터시스템 구조](#컴퓨터시스템-구조)
  - [1. CPU](#1-cpu)
  - [2. 운영체제](#2-운영체제)
  - [3. Mode bit](#3-mode-bit)
  - [1. Timer](#1-timer)
  - [2. I/O Controller](#2-io-controller)
  - [3. Memory Controller](#3-memory-controller)
  - [4. DMA controller](#4-dma-controller)
  - [5. System call](#5-system-call)
  - [6. I/O 작업](#6-io-작업)
  - [7. Interrupt](#7-interrupt)
  - [8. a/synchronous I/O](#8-asynchronous-io)
  - [10. 컴퓨터의 작동방식](#10-컴퓨터의-작동방식)
  - [14. 메모리 계층 구조](#14-메모리-계층-구조)
  - [15. 프로그램이 실행되는 과정](#15-프로그램이-실행되는-과정)
  - [16. 커널의 가상메모리](#16-커널의-가상메모리)

## Introduction

### 1. 운영체제
- 컴퓨터시스템의 자원을 효율적으로 관리하기 위한 컴퓨터 소프트웨어
- 응용프로그램과 하드웨어의 사이에 존재
- 사용자와 컴퓨터 하드웨어를 연결
- 시스템이 부팅되면 메모리에 상주

### 2. 운영체제의 목적
- 컴퓨터시스템의 자원을 효율적으로 관리
- 컴퓨터시스템을 편리하게 사용

### 3. 운영체제의 분류
- 동시작업여부
  - 단일 작업(single tasking)
    - 한번에 하나의 작업만 처리
    - 예) MS-DOS 
  - 다중 작업(multi tasking)
    - 동시에 여러개의 작업 처리
    - 예) UNIX, MS Widows
- 사용자의 수
  - 단일 사용자
    - 예) MS-DOS, MS Windows
  - 다중 사용자
    - 예) UNIX, NT Server
- 처리방식
  - 일괄처리(batch processing)
    - 작업요청을 일정량 모아서 한꺼번에 처리 -> 응답시간이 김
    - 현대에는 거의 안쓰임
  - 시분할방식(time sharing)
    - 컴퓨터 처리능력을 일정한 시간 단위로 분할하여 사용
    - 짧은 응답시간가짐
    - 일반적인 PC 운영체제
  - 실시간(realtime OS)
    - 정해진 시간 안에 반드시 종료가 보장되는 시스템을 위한 OS
    - 예) 원자로/공장 제어, 미사일 제어

### 4. Multiprocessor
- CPU가 여러개
- 여기서 공부할 것은 하나의 CPU가 있는 범용 운영체제

### 5. 커널
- 운영체제 중에서 메모리에 상주하는 핵심부분
- 프로세스, 기억장치, 파일, 입출력 등을 관리

### 6. 운영체제의 예
- UNIX
  - 트리 구조의 파일시스템
  - 대부분 C언어로 작성(C언어는 UNIX프로그램을 만들기위해 개발된 것)
  - 높은 이식성
  - 소스코드 공개
  - 다양한 버전이 존재
    - 예) System V, FreeBSD, Linux
- MS Windows
  - plug and play
  - GUI
  - 선점형 멀티태스킹

### 7. 운영체제의 역할
- CPU 스케줄링
- 메모리 관리
- 파일 관리
- I/O 관리
- 프로세스 관리
- 그 외 하드웨어보호, 네트워킹 등등

<br><br><br>

## 컴퓨터시스템 구조

### 1. CPU
- 매 클럭 주기마다 PC(program counter)가 가리키는 메모리에 접근하여 명령어를 가져옴
- 가져온 명령어를 Decode
- 오퍼랜드를 인출
- 지정된 연산을 수행하고 결과를 저장

### 2. 운영체제
- CPU 통제를 담당
- 현대의 운영체제는 인터럽트에 의해 구동
- 운영체제는 평소에는 CPU 소유권을 갖지 않고, 인터럽트가 발생할때만 운영체제가 CPU 사용
- 인터럽트가 발생하면 인터럽트 백터에 있는 주소를 통해 ISR로 인터럽트를 처리한 후, 다시 사용자 프로그램에 CPU 소유권을 넘겨준다.
- 운영체제가 사용자 프로그램에게 CPU 소유권을 넘기기 전에 mode bit을 1로 바꾸고, Timer를 설정한 후 넘겨준다.

### 3. Mode bit
- 1은 사용자모드: 사용자 프로그램 수행
- 0은 커널모드: OS 코드 수행
- Interrupt 발생 시 mode bit이 0으로 바뀌고 CPU 소유권이 운영체제로 넘어감
- 운영체제가 사용자 프로그램에게 CPU 소유권을 넘기기 전에 mode bit을 1로 바꿈

### 1. Timer
- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생
- CPU를 특정 프로그램이 독정하는 것을 방지
- Time sharing을 구현하기 위해 사용
- 운영체제가 사용자 프로그램에 CPU를 넘겨줄때 mode bit을 1로 하고 Timer를 설정한 후 넘겨준다.
- 사용자 프로그램에 운영체제가 할당한 Timer 시간이 끝나면, timer가 다시 CPU에 인터럽트를 걸어 사용자 프로그램으로 부터 CPU 제어권을 운영체제가 갖게한다.
- 결국 운영체제는 타이머 인터럽트의 도움을 받아서 여러 프로그램을 번갈아가면서 실행할 수 있다.

### 2. I/O Controller
- I/O장치를 관리하는 일종의 작은 CPU
- CPU가 I/O장치에 직접 접근하지 않고 이 Device controller를 통해 접근
- 제어정보를 위해 control register, status register를 가짐
- local buffer(data register)를 가짐

### 3. Memory Controller
- CPU가 메모리를 접근할 때 메모리 컨트롤러를 통해서 접근

### 4. DMA controller
- 직접 메모리에 접근할 수 있는 컨트롤러
- I/O장치가 메모리에 접근하기위해 CPU에 인터럽트를 거는데, 너무 자주 걸기때문에 CPU가 제 할 일을 못하는 경우가 발생
- 이것을 방지하기 위해 I/O 장치의 로컬버퍼 안에 작업이 다 완료되면 DMA가 직접 버퍼내용을 메모리에 복사한 후 CPU에 알려줌
- 이때, 동시에 접근하는 것을 방지하기 위해 memory controller에서 통제

### 5. System call
- 사용자 프로그램이 운영체제의 커널 함수를 호출하는 것

### 6. I/O 작업
- I/O 작업은 사용자 프로그램에서 직접 할 수 없고, 운영체제 커널을 통해서만 작업 가능
- 사용자 프로그램이 I/O 작업이 필요하면 CPU 인터럽트 라인을 통해 인터럽트 발생
- 사용자 프로그램이 운영체제에 요청하는 것을 시스템 콜이라고 함
- 먼저, 사용자 프로그램이 I/O 요청을 위해 운영체제에 인터럽트 발생 (소프트웨어 인터럽트 - system call)
- 운영체제에서 해당 요청을 검사 후, I/O 컨트롤러에 해당 작업을 지시한 후 CPU 소유권을 다른 곳에 넘김
- I/O 장치에서 시킨 일이 다 끝나면 I/O controller에서 CPU에 하드웨어 인터럽트를 발생
- 다른 곳에서 일을 하던 CPU는 인터럽트가 발생한 곳으로 이동 후 해당 작업 수행

### 7. Interrupt
- 인터럽트가 발생하면, PC의 현재주소를 저장한 후 CPU 제어를 ISR(인터럽트 서비스 루틴)에 넘김
- 인터럽트 벡터는 ISR의 주소를 가지고 있음
- ISR은 각각의 인터럽트마다 수행해야할 매뉴얼로 운영체제 안에 커널함수로 정의되어있음
- 하드웨어 인터럽트를 Intrrupt, 소프트웨어 인터럽트를 Trap

### 8. a/synchronous I/O
- synchronous I/O
  - I/O 요청 후 I/O 작업이 다 완료될때까지 기다림
- asynchronous I/O
  - I/O 요청 후 I/O 작업이 끝나기를 기다리지 않고 바로 CPU 제어를 얻어와서 다른작업을 함

### 10. 컴퓨터의 작동방식
- CPU는 매번 PC에 해당하는 메모리 주소에 있는 명령어를 실행함
- 메모리에는 사용자 프로그램, 운영체제 커널 등이 존재한다.
- CPU는 mode bit이라는 것이 있는데, 이것이 0이면 CPU의 ISA(기계어집합)를 전부 실행할 수 있고, 1이면 한정된 기계어(Instruction)들만 실행할 수 있음
- 운영체제가 CPU 제어권을 가지고 있을때는 mode bit이 0이라서 모든 instruction을 실행 할 수 있음
  - 예를들어, 다른 사용자 프로그램의 메모리에 접근하는 것 등의 mode bit이 0일때만 할 수 있는 instruction들이 있음
  - 또, I/O 장치에 접근하는 모든 instruction들은 mode이 0일때, 즉, 운영체제만 실행할 수 있도록 막혀있다.
  - mode bit이 1일때는 사용자프로그램이 CPU를 갖고 있을때로 한정된 명령어들만 실행가능함 (예를들어, 운영체제 커널의 메모리에 접근한다거나, I/O장치에 접근하는것 등은 mode bit이 0일때만 가능하므로 사용자프로그램이 CPU를 갖고있을때는 불가능)
- 만약, CPU가 사용자프로그램이 있는 메모리 주소에서 Instruction들을 실행하다가 I/O작업을 해야할 상황이 생기면, 현재 mode bit이 1이므로 (사용자프로그램에서 CPU를 가지고있으므로) I/O 작업을 못한다.
- 따라서, I/O 작업을 할 수 있는 (mode bit이 0인) 운영체제가 있는 메모리로 CPU를 이동시켜야하는데 운영체제가 있는 메모리로 CPU를 이동시키는 것은 mode bit이 1일때는 못하므로 사용자프로그램에서 의도적으로 CPU에 있는 Interrupt line을 필요한 작업에 알맞은 번호로 세팅을 한다. (예를들어, 키보드 입력이 필요하면 키보드 입력 인터럽트 3번으로 세팅)
- 그러면, CPU는 인터럽트 라인이 세팅되었으므로 하던 일을 멈추고 인터럽트 라인의 세팅된 번호에 해당하는 매뉴얼이 있는 운영체제가 상주하는 메모리 주소로 이동해야한다.
- 운영체제가 있는 메모리로 간 CPU는 이제 인터럽트 라인에 세팅된 번호에 해당하는 매뉴얼을 수행해야하는데, 이 번호에 해당하는 매뉴얼이 있는곳을 나타내는 것이 인터럽트 벡터이다. 또한, 이 인터럽트에 해당하는 매뉴얼들이 인터럽트 서비스 루틴(ISR)이다. ISR은 운영체제 안에 존재하며, 인터럽트마다 수행해야할 커널 함수들이 정의되어있다.
  - 운영체제로 간 CPU는 인터럽트 벡터에 있는 해당 인터럽트 번호에 해당하는 메모리 주소로 이동해야한다. (운영체제의 커널함수가 있는 주소) 해당 인터럽트에 해당하는 메모리 주소에는 ISR이 있는데, 이 ISR이 해당 인터럽트에 알맞은 처리 작업 명령어들이 있다. CPU는 이제 이 명령어들을 수행한다.
  - 위에서 받은 인터럽트가 키보드 입력을 받는 인터럽트이므로, ISR에는 키보드 입력을 요구하는 작업들이 있다. 이 작업을 실행하여 키보드 입력을 요구한다.
    - 이때, 키보드와 같은 I/O 장치들에 직접 접근하지는 않고, device controller를 통해 접근한다. 각 I/O 장치들 마다 자신들을 통제하는 cpu들이 있는데 이것을 device controller라고한다. 이 device controller에는 제어정보를 위한 control register, 상태정보를 위한 status register, 현재 값을 저장하기 위한 local buffer들이 있다.
    - I/O 작업은 동기식 입출력, 비동기식 입출력 두 가지가 있다. 동기식 입출력은 사용자 프로그램에서 I/O 작업을 요청 후 해당 입출력 작업이 완료될때까지 기다리는 것이다. 하지만, 전부 다 기다리는 것은 너무 낭비가 크기 때문에 주로 기다리지 않고, 다른 사용자 프로그램에게 CPU 제어를 주는 방법을 사용한다. 비동기식 입출력은 해당 입출력 작업을 기다리지 않고, 요청만 해놓고 곧바로 해당 프로그램의 다음 명령을 실행하는 것이다.
    - I/O 작업은 Cpu에 비해 수백만배 속도가 더 느리다. 그래서 CPU가 이 I/O 작업을 계속 기다리는 것은 낭비이므로, 운영체제는 cpu 제어권을 다른 프로그램에게 넘겨 CPU가 계속 일을 할 수 있도록 한다. (운영체제가 cpu 제어를 넘긴다는것은 즉, CPU가 실행하고있는 ISR에 분기 명령어가 있다는 뜻)
    - I/O 요청 후, I/O 작업이 다 끝나지 않아서 CPU가 다른 일을 하고 있다고 생각해보자. 이때, I/O 장치에서 운영체제에서(ISR 해당하는 작업) 요청한 작업이 다 끝나면, I/O 장치(device controller)는 CPU에게 인터럽트 라인을 세팅하여 I/O 작업이 모두 끝났음을 알려준다. 이러한, 하드웨어에서 요청하는 인터럽트를 Interrupt라고 한다.
      - 하지만, 이때 너무 많은 I/O 장치들이 CPU에 인터럽트를 건다면, 사용자 프로그램에서 작업하던 CPU가 하던 일을 멈추고 다시 OS로 가서 인터럽트를 처리하는 등 상당한 오버헤드가 발생한다. (예를들어, I/O 장치에서 입력이 생기면 메모리에 가서 입력값을 복사해줘야하는데 메모리에 접근할 수 있는 것은 CPU 뿐 이므로 인터럽트를 발생시켜줘야한다.)
      - 즉, 이런 작은 일 하나하나 마다 CPU에 인터럽트를 걸면 CPU에 발생하는 오버헤드가 너무 커지기 때문에 DMA controller라는 장치가 있다.
        - 이 DMA는 direct memory access로 원래 cpu만 직접 접근할 수 있는 메모리에 DMA도 CPU의 중재없이 메모리에 접근할 수 있다. 즉, I/O 장치는 I/O 작업을 요청받으면, 자신이 가지고 있는 버퍼에 요청한 내용을 추가하고, DMA는 이 버퍼의 내용을 메모리에 추가한다. 여기서 버퍼의 내용은 block단위이다. 그 후, 요청한 만큼 데이터가 추가되면, DMA가 CPU에 인터럽트를 한 번만 걸어서 알려준다. 이렇게 함으로서 CPU가 인터럽트 되는 빈도를 줄여 오버헤드를 감소시킬 수 있다.
      - 본래 CPU만 메모리에 접근할 수 있다. 하지만, I/O 장치가 CPU에 인터럽트를 걸
    - 그러면, CPU는 또 다시 운영체제로 가서 (CPU는 운영체제 아니면 사용자프로그램 둘 중 하나의 일을한다. 이 처럼 현대의 운영체제는 인터럽트가 발생할때만 CPU를 소유한다.) 아까 분기한 ISR 명령어로 돌아간뒤, 남아있는 ISR 작업을 완료한다. (여기서는 키보드의 입력 인터럽트였으므로, 입력받은 값을 메모리로 복사해 온다)
    - ISR 작업을 다 완료하면, 이제 운영체제는 CPU를 다른 사용자프로그램에 넘겨준다. 이때, 그냥 넘겨주지는 않고 mode bit를 1로, Timer를 일정시간으로 설정한 뒤 넘겨준다.(넘겨준다라고 했는데, 실제로는 CPU가 ISR 명령어를 모두 완료하면, ISR 명령어의 끝에 mode bit, timer 설정 명령어를 실행하고 아까 진행 중이던 사용자 프로그램 메모리 주소로 JUMP하는 명령어를 실행한다.)
  - timer란, 
- 이것처럼 사용자 프로그램과 같은 소프트웨어가 직접 인터럽트를 발생시킨 것을 Trap(소프트웨어 인터럽트)이라고 하며, Trap에는 두 종류가 있는데, 위에처럼 사용자 프로그램이 직접 운영체제의 커널함수를 호출하는 것을 System call이라고하며, 프로그램 오류에 의해서 호출되는 인터럽트는 Exception이라고 한다.
- CPU가 운영체제가 있는 메모리에서 ISR 작업을 완료하면, 이제 운영체제 소프트웨어가 CPU의 소유권을 다른 사용자 프로그램이 있는 메모리 주소에 넘겨준다.(기계어의 JUMP등의 명령어)
- 이때, 운영체제는 그냥 넘겨주지 않고, mode bit을 1로 바꾸고, timer에 일정시간을 설정한 후에 CPU의 제어권을 다른 사용자 프로그램으로 넘긴다.
- 여기서 timer란, 컴퓨터 내에 존재하는 하드웨어로 CPU를 특정 프로그램이 독점하는 것을 방지하는 장치이다. 운영체제가 작업이 다 끝나면 타이머에 시간을 설정한 후 사용자 프로그램에 CPU를 넘겨준다. 타이머에 할당된 시간이 끝나면, 타이머에서 CPU의 Interrupt line을 통해 인터럽트를 발생시키킨다. 그럼 CPU는 다시 운영체제로 가서 운영체제가 지시하는 작업을 수행한다. 이떄 운영체제는 또 타이머에 시간을 설정한 후 다른 사용자 프로그램에 CPU를 넘겨준다. 이런 방식으로 운영체제는 CPU가 매우 짧은 시간동안 여러 프로그램들을 작업할 수 있도록 한다. 이런 방식을 Time sharing이라고 한다.

### 14. 메모리 계층 구조
- Register -> Cache -> Main memory -> Magnetic Disk -> ...
- 오른쪽으로 갈수록 가격과 속도가 낮다. 
- Register, Cache는 SRAM으로 만든다. SRAM은 트랜지스터 6개로 구현되며, 속도가 빠르고 전력이 공급되는 한 정보를 유지한다.
- Main memory는 DRAM으로 만들어져있다. DRAM은 트랜지스터 1개로 구성되며, 정보 유지를 위해 따로 리프래쉬를 해줘야한다.
- SRAM이 DRAM 보다 더 비싸고, 크고, 빠르다.
- 레지스터는 CPU 코어 내부에 있고, 캐시는 코어 외부 CPU 내부에 있다.
- 레지스터에는 IR, MBR, MAR 등 여러종류가 있다. 이 레지스터에는 Instruction, 오퍼랜드 등이 Load-Store 방식으로 저장된다.
- 캐시는 램에서 자주 사용되는 데이터를 지역성의 원리에 따라 재사용을 목적으로하는 저장공간으로, CPU와 RAM의 거리 차이를 좁히기 위해 둔 장치이다.

### 15. 프로그램이 실행되는 과정
- 대부분의 프로그램은 하드디스크에 파일형태로 담겨있다.
- 프로그램의 실행파일을 실행하면, 프로그램의 Address space가 형성되는데 이것은 메모리 주소 공간이다. 즉, 0번지부터 시작되는 프로그램 만의 독자적인 주소 공간이 생성된다.
- 이 독자적인 주소공간은 code, data, stack 영역으로 구성된다. code는 프로그램의 기계어 코드, data는 전역변수와 같은 프로그램에 사용되는 되는 자료구조, stack은 함수 구조의 지역변수, 매개변수와 같은 변수들이 저장된다.
- 이러한 독자적인 주소공간을 가상메모리라고 한다.
- 가상메모리가 완료되면, 이제 이것을 물리적인 메모리에 적재시킨 후 프로그램을 실행한다. 이때, 메모리에는 커널 영역이 있는데 이것은 운영체제의 프로그램이 적재된 것으로 컴퓨터가 부팅 후 종료될때까지 메모리에 항상 상주한다.
- 일반 사용자 프로그램들은 실행되면, 가상메모리를 생성한 후 물리적인 메모리에 적재하는데, 이때 가상메모리의 모든 부분을 메모리에 담는 것은 아니고 프로그램의 실행에 당장 필요한 것만 메모리에 적재시킨 후, 그렇지 않은 부분은 하드디스크의 Swap area에 내려놓게 된다.
  - 가상메모리의 주소를 물리적인 메모리의 주소로 적재시킬때, 변환 작업이 필요한데, 이것을 `Address translation`이라고 하며, 운영체제가 하는 것은 아니고 주소변환을 담당하는 하드웨어 장치에서 이것을 담당한다.
  - Swap area는 메모리 용량의 한계로 메모리 연장 공간으로 사용되는 것이다. 즉, 프로그램이 종료되면 사라지는 램과 마찬가지로 Swap area도 사라진다.
- 즉, 가상메모리는 프로그램이 실행되면 생성되는 각 프로그램마다 갖는 독자적인 주소 공간이며, 실제 물리적으로 존재하는 것은 아니다.
- 프로그램의 실행파일을 실행하면, 프로그램 구동에 꼭 필요한 부분만 물리적인 메모리에 적재되어 프로세스가 된다.

### 16. 커널의 가상메모리
- code: 하드웨어 자원을 관리하는 코드, (하드웨어)인터럽트 처리 코드, 시스템콜 처리 코드, ...
- data: 운영체제가 관리를 위해 사용하는 여러 자료구조, 프로세스 관리를 위해 자용하는 자료구조(PCB)
- stack: 운영체제도 함수 구조로 코드가 짜여져있기 때문에 함수를 호출하거나 반환할때 사용