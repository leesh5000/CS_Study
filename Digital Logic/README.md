# Digital Logic

## Contents

- Ch 1 : [Introduction](#introduction)
- Ch 2 : [Number System](#number-system)
- Ch 3 : [Logic Gate](#logic-gate)
- Ch 4 : [Boolean Algebra](#boolean-algebra)
- Ch 5 : [SOP and POS](#sop-and-pos)
- Ch 6 : [Karnaugh Map](#karnaugh-map)
- Ch 7 : [Logic Circuit](#Logic-Circuit)
- [Reference](#reference)

<br>[Home](https://github.com/leesh5000/ComputerScience_Study)</br></br>

## Introduction

### 아날로그와 디지털 ###
아날로그 양(Analog Quantities)은 시간에 따라 연속적으로 변화하는 값을 말한다. 온도, 습도, 소리과 같이 우리 주변에서 볼 수 있는 대부분의 자연현상들이 이 아날로그에 속한다. 디지털 양(Digital Quantities)은 아날로그 양과 반대되는 개념으로 이산적인(discrete) 값을 말한다.

### 아날로그 신호를 디지털 신호로 변환하는 방법 ###
아날로그 신호를 디지털 신호로 변환하기 위해서는 표본화(Sampling), 양자화(Quantizing), 부호화(Encoding)를 거쳐야한다. 0시부터 24시까지의 시간-온도 그래프를 디지털 값으로 변환한다고 생각해보자.
연속적인 값을 불연속적인 디지털 값으로 만들기위해 0시부터 24시까지 연속적인 시간을 특정 시간을 기준으로 나눈 후, 해당 시간에 맞는 표본값을 추출해야하는데 이러한 과정을 표본화라고 할 수 있다.
표본화 된 데이터 값은 32.211, 4.0911...과 같이 아직 연속적인 값을 갖는다. 이러한 값을 컴퓨터가 나타낼 수 있는 최대 정확도의 값으로 근사화 시켜야하는데 이것을 양자화라고한다. 부호화란, 표본화와 양자화를 마친 데이터를 0과 1로 이루어진 이진수로 변환하는 과정이다. 아날로그 신호를 디지털 신호로 변환하는 과정 중 표본화와 양자화 과정에서는 데이터의 손실이 일어난다.

[A/D Converter의 작동원리](https://www.rohm.co.kr/electronics-basics/ad-converters/ad_what2)

### 디지털시스템의 장점 ###
그렇다면 아날로그보다 정확도가 떨어지는 디지털 시스템을 왜 사용할까? 디지털 시스템을 사용하는 이유에는 다음 몇 가지가 있다.  
1. 0과 1만 디지털 신호로 사용하기 때문에 외부 환경(열이나 잡음)에 강하다.
2. 0과 1만 사용하기 때문에 데이터의 저장이나 가공이 간편하다.
3. 연속적인 전기신호를 0과 1로만 표현하기 때문에 시스템 설계가 간편하다. 

### 이진값과 전압 ###
연속적인 전기 신호를 어떻게 불연속적인 0과 1의 논리데이터로 나타낼 수 있을까? 일반적으로 Positive Logic으로 전압이 기준값보다 낮을 때는 0, 높을때는 1의 값을 갖도록 하는 것이다. 이 때, 0에서 1로 올라가는 부분을 상승엣지라고 부르고 그 반대를 하강엣지라고 한다. 실제로는 상승과 하강은 바로 일어나지는 않고 어느정도 시간을 두고 발생한다.

### 주기와 주파수 ###
주기란, 상승(하강)엣지부터 다음 상승(하강)엣지까지를 말하며 단위는 초이다. 주파수는 1초에 진동하는 횟수를 말하며 단위는 Hz이다. 예를들어 1초에 1000번 진동하는 신호는 주파수가 1000Hz라고 할 수 있다.
- Period (T) : seconds
- Frequency (f) : Hertz (cycles per second)
- T = 1 / f 

### 논리회로의 종류 ###
1. 조합논리회로 (combinational logic circuit) : 기본 게이트의 조합으로 구성되는 회로 `ex) 리모컨의 숫자 버튼`
2. 순차논리회로 (sequential logic circuit) : 플립플롭(flip-flop) 등 현재 상태를 저장하는 저장소자가 포함된 논리회로 `ex) 리모컨의 채널 +/- 버튼`

### 저장소자의 종류 ###
- Latch, Flip-flop
- Register (플립플롭이 여러개 모인 것)
- 메모리 : (공통점)전원을 끄면 저장되어 있던게 사라지는 휘발성 메모리
    - DRAM (dynamic random access memory) : 저장된 데이터가 시간이 지나면 사라지는 메모리, 주기적 Refresh를 해주지 않으면 데이터가 사라진다. SRAM보다 속도도 느리지만 가격이 저렴하기 때문에 컴퓨터의 주 메모리로 사용한다.
    - SRAM (static random access memory) : Refresh를 하지 않아도 데이터가 사라지지 않는 메모리, 캐시 메모리로 사용한다.

<br>[Contents](#Contents)<br><br>

## Number System
컴퓨터공학에서 중요하게 알아야 할 2진수와 16진수가 있다. 2진수의 digit은 0과1, 16진수의 digit은 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F이다. 2진수와 16진수는 4비트 단위로 변환될 수 있다. 

ex) 0111<sub>(2)</sub> = 7<sub>(16)</sub> , 1111<sub>(2)</sub> = F<sub>(16)</sub>

BCD (binary coded decima)
십진수의 각 자리 수를 4비트의 2진수로 표현한 것을 말한다. BCD의 덧셈도 있는데 구글링하면 쉽게 찾을 수 있으므로 여기서는 다루지 않는다.

ex) 35<sub>(10)</sub> = (0011 0101)<sub>BCD</sub>, (0001 0111 0000)<sub>BCD</sub> = 170<sub>(10)</sub>

#### MSB and LSB
- MSB (most significant bit) : 가장 왼쪽에 있는 비트
- LSB (least significant bit) : 가장 오른쪽에 있는 비트

### 컴퓨터가 수를 표현하는 방법
0과 1로 이루어진 이진수는 컴퓨터가 의미를 구분할 수 있는 전류가 흐르냐/흐르지 않냐와 대응되기 좋고, 디지털 시스템의 장점때문에 컴퓨터가 사용하기 좋은 수 체계이다. 십진수를 이진수로 변환하거나 이진수를 십진수로 변환하는 쉽고 검색해보면 많이 나오기 때문에 여기서는 다루지는 않겠다.

#### 이진수의 음수 변환의 필요성
컴퓨터는 이진수로 수를 나타낸 다는 것을 알았다. 컴퓨터는 이진수 체계를 이용하여 데이터를 저장하고, 사칙연산을 하여 데이터를 가공하기도 한다. 컴퓨터가 덧셈을 할 때는 가산기(Adder)라는 논리회로(logic gate)를 통해서 덧셈을 한다. 그런데 만약 컴퓨터가 뺄셈을 하려고 한다면 뺄셈기라는 회로를 또 만들어주어야할까? 또는 곱셈이나 나눗셈을 한다고 했을 때 각각의 회로를 하나씩 만드는건 큰 낭비가 될 수가 있다. 따라서 사실 컴퓨터는 모든 사칙연산을 가산기 하나만으로 해결한다. 예를 들어 뺼셈의 경우에는 39 - 20 은 39 + (-20) 과 같이 해결하고 곱셈과 나눗셈의 경우 다음과 알고리즘에 의해 자리수를 맞춰주고 가산기로 다 더해서 계산한다.

[컴퓨터가 곱셈/나눗셈을 하는 원리](https://blackinkgj.github.io/AL/)

따라서 컴퓨터는 이제 이진수를 음수로도 표현해야 한다. 사람의 경우 앞에 부호만 붙여주면 되지만 컴퓨터는 모든 수를 0과1로 구분하기 때문에 - 부호를 인식할 방법이 없다. 이러한 문제를 해결하기 위해 이진수를 음수로 표현하는 몇 가지 방법이 있는데 다음과 같다.

1. Sign-magnitude (부호와 절대값) : msb는 부호를 담당하고, 나머지 비트는 절대값을 담당하는 방법
2. 1's complement (1의 보수) : 모든 비트를 반전시켜 음수를 표현하는 방법
3. 2's complement (2의 보수) : 1의보수에 1을 더해서 음수를 표현하는 방법

예를들어, -39를 8비트로 각각의 방법으로 표현해보자.
1. Sign-magnitude : 십진수 39를 8비트 이진수로 나타내면 00100111이므로 sign-magnitude로 음수를 표현하면, 10100111이다.
2. 1's complement : 십진수 39는 00100110 이고, 모든 비트를 반전시켜 -39를 11011000로 표현한다.
3. 2's complement : 1의보수에 1을 더해서 표현한다. 11011001

주의할 점은, 십진수 39를 8비트 칸의 이진수로 변환할 때는 방법이 하나밖에 없기 때문에 00100111밖에 없다. 하지만, 십진수 -39를 이진수로 변환할 때는 방법이 3가지가 있기 때문에 각 방법에 따라 다르게 표현된다. 다행히도 이 세가지 방법 중 2의 보수 체계가 다른 방법보다 월등히 좋기 때문에 컴퓨터는 특별한 일이 없는 이상은 2의 보수 체계를 사용한다. 2의 보수가 음수를 표현하는데 있어서 다른 방법보다 좋은 이유는 다음과 같다.

| Sequence | 2의보수 | 1의보수 | 부호와절대값 |
|:---:|:---:|:---:|:---:|
| 0111 | 7 | 7 | 7 |
| 0110 | 6 | 6 | 6 |
| 0101 | 5 | 5 | 5 |
| 0100 | 4 | 4 | 4 |
| 0011 | 3 | 3 | 3 |
| 0010 | 2 | 2 | 2 |
| 0001 | 1 | 1 | 1 |
| 0000 | 0 | 0 | 0 |
| 1111 | -1 | -0 | -7 |
| 1110 | -2 | -1 | -6 |
| 1101 | -3 | -2 | -5 |
| 1100 | -4 | -3 | -4 |
| 1011 | -5 | -4 | -3 |
| 1010 | -6 | -5 | -2 |
| 1001 | -7 | -6 | -1 |
| 1000 | -8 | -7 | -0 |

위 표와 같이 1의 보수와 부호와 절대값은 0이 두 개가 생기는 문제가 발생하며, 부호와 절대값 방법은 수의 순서가 자연스럽지 않기 때문에 컴퓨터는 음수 표현 방법으로써 2의 보수를 사용한다. 이제 컴퓨터가 이진수 체계를 사용하며, 음수의 경우에는 2의 보수로 음수를 표현한다는 것을 알았다. 하지만, 아직 정리되지 않은 부분이 있다. 만약, 4비트 칸을 가진 이진수 1111을 십진수로 변환한다고 했을 때, 답이 15도 되고, -1도 되어버린다는 문제가 있다.
따라서, 이진수를 표현할때는 반드시 부호가 있는지 없는지(signed/unsigned)를 명시해주던가 아니면 컴퓨터가 2의보수로 음수를 표현하므로 2의보수 1111인지를 명시해줘야한다. 이것이 우리가 프로그래밍 언어에서 signed와 unsigned가 존재하는 이유이다.

즉, 위의 문제를 다시 올바르게 표현하면 "4비트 칸을 가진 signed 1111을 십진수로 변환하라." 혹은 "2의보수 1111을 십진수로 변환하라." 가 된다.

정리를 해보자면,
1. 십진수 39를 이진수로 변환 (8비트) : 우리가 평소알던 방법대로 변환하면 된다. -> 39 = 00100111
2. 십진수 -39를 이진수로 변환 (8비트) : 이진수를 음수로 표현하기 위해 2의보수로 -39를 표현하면 된다. 즉, 39의 이진수에 1의보수를 취하고 1을 더한다. 그리고, 원래 십진수가 -39였기 때문에 signed를 해주던가 2의보수인지를 알려준다. -> 39 -> 00100111 -> 11011000 -> 11011001 -> signed 11011001 or 2의보수 11011001
3. signed 11011001(혹은 2의보수 11011001)를 십진수로 변환 : msb만 음수로 계산한다. -> 2<sup>7</sup> * (-1) + 2<sup>6</sup> * 1 + 2<sup>5</sup> * 0 + 2<sup>4</sup> * 1 + 2<sup>3</sup> * 1 + 2<sup>2</sup> * 0 + 2<sup>1</sup> * 0 + 2<sup>0</sup> * 1 = -39
    - signed 01011001인 경우는 -> 2<sup>7</sup> * (0) + 2<sup>6</sup> * 1 + 2<sup>5</sup> * 0 + 2<sup>4</sup> * 1 + 2<sup>3</sup> * 1 + 2<sup>2</sup> * 0 + 2<sup>1</sup> * 0 + 2<sup>0</sup> * 1
    - 즉, signed 이진수에서는 msb가 부호를 결정한다. 1이면 음수, 0이면 양수
4. unsigned 11011001을 십진수로 변환하기 : unsigned이므로 평소 방법대로 하면 된다. 즉, 1번 방법을 거꾸로 하면된다. -> unsigned 11011001 -> 217

### 이진수의 연산
이진수의 덧셈은 unsigned와 signed 이진수를 다르게한다. unsigned 이진수의 덧셈은 일반 덧셈과 똑같이 한다. signed 이진수 덧셈은 unsigned와 똑같이 하는데 마지막에 발생하는 carry는 무조건 버려야한다.
```
     <unsigned 이진수의 덧셈>                   <signed 이진수의 덧셈>
                                           
       00001111       15                      00001111       15
     + 11111010    + 250                    + 11111010    + (-6)
     -------------------                    --------------------
      100000001      265                      00001001        9      [100001001 이지만, unsigned 이진수 덧셈이므로 마지막 캐리는 버려야한다.]
```

이진수의 뺄셈은 unsigned나 signed나 똑같다. - 부호를 가진 수(subtrahend)를 2의보수로 변환해서 더하면 된다.
```
     <이진수의 뺄셈>
     
     ex) 15 - 32 = -17
     
     15 - 32 = 15 + (-32) 이고, 이것을 이진수로 변환하면
     00001111 + 11011111 = 11101110 이다.
     11101110 = -17 이므로 연산결과가 옳다.
```

#### signed 이진수의 오버플로우(overflow)
singed 이진수의 덧셈에서 수의 표현범위를 벗어나는 오버플로우 현상이 일어나는데 그 예는 다음과 같다. 따라서, 양수+양수=음수이거나 음수+음수=양수가 되면 signed 이진수의 연산에서 오버플로우가 발생했다는 것을 알 수 있다.
```
     <양수 + 양수 = 음수가 되는 경우>                  <음수 + 음수 = 양수가 되는 경우>
        
        01111111   (127)                           10000000   (-128)
      + 00000001     (1)                         + 11111111     (-1)
      ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                      --------------------
        10000000  (-128)                           01111111    (127)    [101111111 이지만, unsigned 이진수 덧셈이므로 마지막 캐리는 버려야한다.]
```

#### unsigned 이진수의 오버플로우
unsigned 이진수의 경우에는 유효범위를 넘어가면 오버플로우가 발생한다. 예를들어 8비트의 이진수를 생각해보자. 8비트 unsigned 이진수의 경우 유효범위는 0~255이다.
```
     <유효범위를 벗어나지 않음>                         <유효범위를 벗어난 경우>
       
       01010110     (86)                           11010110     (214)
     + 01110101   + (117)                        + 01110101   + (117)
     ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                      ---------------------
       11001011     (203)                          01001011      (75)    [101001011 이지만, 8비트이기 때문에 앞의 1을 표현할 비트 자리가 부족]
```

### Floating-point number
floating-point number는 실수를 컴퓨터상에서 근사값으로 표현할 때 소수점의 위치를 고정하지 않고, 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 Significant(가수)와 소수점의 위치를 풀이하는 Exponent(지수)로 나누어 표현한다. 예전에는 부동소수점 표준이 굉장히 많았지만 현재는 IEEE754 Standards에서 제시한 Single precision(단정도), Double precision(배정도) 두 포맷이 쓰인다. c언어에서 32비트를 쓰는 float 이 Single precision이고 64비트를 사용하는 double이 double precision이다.

```
                  <Single Precision>
    +------+--------------+-------------------------+
    | S(1) |     E(8)     |          f(23)          |
    +------+--------------+-------------------------+
    
                       <Double Precision>
    +------+------------------+------------------------------+
    | S(1) |       E(11)      |             f(52)            |
    +------+------------------+------------------------------+
```

각각의 값은 다음과 같이 표기된다. 부동소수점의 원리는 복잡하므로 여기서는 표기법만 알아본다.
- Single Precision : F = (-1)<sup>S</sup> x 1.f x 2<sup>E-127</sup>
- Double Precision : F = (-1)<sup>S</sup> x 1.f  x 2<sup>E-1203</sup>

<br>[Contents](#Contents)<br><br>

## Logic Gate
논리소자(Logic gate, Logic element)는 논리 연산에 기본이 되는 논리소자를 말한다. 여기서 "Gate"라는 말은 정보흐름의 허용 및 저지를 결정하는 단자 또는 소자를 말한다. 논리소자는 여러 개의 회로소자들로 구성된다. 

#### 회로소자
회로소자(Circuit Element란, 신호처리(증폭, 필터링, 변조)를 위한 가장 기본적인 회로구성요소를 말한다. 예를들어, 수동소자인 `Registor, Inductor, Capacitor`와 능동소자인 `transistor, diode` 등이 있다. 수동소자는 에너지 소비가 가능한 소자이며 전압과 전류의 관계가 선형적인 특징을 갖는다. 능동소자는 에너지 공급이 가능한 소자이며, 전류를 제어`diode`하거나 증폭`transistor`하는 역할을 한다. 이러한 기본 회로소자를 조합해서 AND,NOT,OR 등의 논리소자를 만드는 것이다. 

[AND,OR,NOT게이트의 원리](https://blog.naver.com/PostView.nhn?blogId=bitnang&logNo=70172717438&parentCategoryNo=&categoryNo=49&viewDate=&isShowPopularPosts=true&from=search)
[CMOS Inverter, NAND, NOR 원리 (9강 19분)](http://www.kocw.net/home/search/kemView.do?kemId=1319470)

#### 논리소자의 특징
1. 입력신호들에 취해지는 논리 조합에 따라 출력이 결정된다.
2. 1 이상의 논리값으로 부터 새로운 논리값을 만든다.

#### 논리소자의 구분
1. 기본게이트 : NOT, AND, OR
2. 범용게이트 : NAND, NOR (모든 다른 게이트들은 이 2개의 범용게이트들을 대체하여 표현 가능하다.)
3. 기타게이트 : XOR, XNOR

기본 논리게이트의 종류로는 Buffer, Inverter, AND, NAND, OR, NOR, XOR, XNOR 등이 있다. Buffer, Inverter는 입력값이 하나인 1-input Gate이다.

#### Verilog
전자시스템을 설명하는 하드웨어 기술 언어이다. (HDL, Hardware Description Language) 

### Buffer
버퍼는 입력과 출력이 같은 논리게이트이다.

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : A
- Verilog : A

#### Truth table
A, X는 각각 입력과 출력
| A | X |
|:---:|:---:|
| 0 | 0 |
| 1 | 1 |

### Inverter
입력을 반전하여 출력하는 논리게이트이다. NOT이라고도 한다. 1의보수 발생기로 응용할 수 있다. 

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : ~A or A̅ or A'
- Verilog : ~A

#### Truth table
A, X는 각각 입력과 출력
| A | X |
|:---:|:---:|
| 0 | 1 |
| 1 | 0 |

### AND
두 수의 입력이 모두 1일 경우에만 출력이 1인 논리게이트이다. AND 게이트는 0 • 0 = 0, 0 • 1 = 0, 1 • 0 = 0, 1 • 1 = 1이 되는 성질 때문에 `논리곱(Conjunction)`이라고 불린다. AND 게이트는 신호를 Masking하는데 사용된다.

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : A•B
- Verilog : A&B

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

### OR
두 수의 입력 중 하나라도 1인 경우에 출력이 1 또는 두 수의 입력이 모두 0일 경우에만 0인 논리게이트를 말한다. 0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, 1 + 1 = 1이 되는 성질 때문에 `논리합(Disjunction)`이라고 불린다.

- Boolean Algebra : A+B
- Verilog : A|B

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

### NAND
두 수의 입력이 1일 경우에만 출력이 0인 논리게이트이다. AND의 출력을 NOT 시킨 것과 같다. NAND 게이트는 negative-OR 게이트와 등가이다.

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : (A•B)'
- Verilog : ~(A&B)

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 1 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

### NOR
두 수의 입력 중 하나라도 1인 경우에 출력이 0 또는 두 수의 입력이 모두 0일 경우에만 출력이 1인 논리게이트를 말한다. OR의 출력을 NOT 시킨 것과 같다. NOR 게이트는 negative-AND 게이트와 등가이다.

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : (A+B)'
- Verilog : ~(A|B)

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 1 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 0 |

### XOR
Exclusive-OR의 줄임말로 두 수가 다를 때 출력이 1 또는 1의 개수가 홀수일 때 출력이 1인 논리게이트를 말한다. 1의 개수가 홀수일 때 1을 출력하므로 홀수(Odd) 함수라고도 한다. 또한, 두 수가 다를 때 1을 출력하는 특징 때문에 인공위성이나 항공기 등과 같이 매우 중요한 회로에 쓰이는데, 입력에 똑같은 A회로 2개를 놓고 2개의 회로가 서로 다르게 들어오면 오류를 출력하도록 만들 수 있다.

[심볼 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : A⊕B (= A̅B+AB̅ )
- Verilog : ~(A|B)

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

### XNOR
Exclusive-NOR의 줄임말로 두 수가 같을 때 출력이 1 또는 1의 개수가 짝수일 때 출력이 1인 논리게이트를 말한다. 1의 개수가 짝수일 때 1을 출력하므로 짝수(Even) 함수라고도 한다. XNOR는 XOR의 NOT과 같다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

- Boolean Algebra : (A⊕B)'
-  Verilog Equation : ~(A^B)

#### Truth table
A, B는 입력, Q는 출력
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 1 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

<br>[Contents](#Contents)<br><br>

## Boolean Algebra
부울 대수(boolean algebra)는 어떤 명제를 참과 거짓을 뜻하는 0,1과 논리곱, 논리합, 부정의 개념을 이용하여 기호화 한 것이다. 컴퓨터공학에서 부울대수를 이용하면 논리회로의 논리관계를 대수적으로 표현하기에 매우 유용하다. 

#### Algebra 
Algebra란, 수 들사이에 연산 및 그 관계를 말한다.

#### 부울 대수를 단순화해야하는 이유
앞으로 여러 챕터에 걸쳐서 부울 대수를 단순화하는 방법에 대해서 배운다. 왜 부울대수를 단순화해야 할까?

부울대수는 같은 결과를 나타내는 식이라도 정리가 되지 않으면 굉장히 복잡한 식이 될 수도 있고, 단순한 식이 될 수도 있다. 부울대수는 모든 컴퓨터 논리소자를 표현하는 식이므로 부울대수를 단순화한다는 것은 곧 물리적인 컴퓨터 내부의 물리적인 논리회로들을 단순화 할 수 있다는 것을 말한다. 컴퓨터 내부 회로를 단순화하면 컴퓨터의 빠른속도, 작은크기, 낮은 전력소모 등을 가져올 수 있다.   

### 부울대수의 법칙과 규칙

#### 교환법칙 (Commutative Law)
- 부울 합 (OR) : A+B = B+A

| A | B | A+B | B+A |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 |

- 부울 곱 (AND) : A•B = B•A

| A | B | A•B | B•A |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 |

#### 결합법칙 (Associative Law)
- A+(B+C) = (A+B)+C
- A•(B•C) = (A•B)•C

#### 배분법칙 (Distributive Law)
- A•(B+C) = (A•B)+(A•C)

| A | B | C | B+C | A•(B+C) | (A•B)+(A•C)
|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 | 0 | 0 | 
| 1 | 0 | 0 | 0 | 0 | 0 | 
| 0 | 1 | 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 1 | 1 | 1 |
| 0 | 1 | 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 1 | 1 | 1 |

- A+(B•C) = (A+B)•(A+C) [일반적인 대수관계와 다르니까 주의]

| A | B | C | B•C | A+(B•C) | (A+B)•(A+C)
|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 | 0 | 0 | 
| 1 | 0 | 0 | 0 | 1 | 1 | 
| 0 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 |

#### 부울대수의 규칙
1. A + 0 = A

| A | 0 | A + 0 |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 1 |

2. A + 1 = 1

| A | 1 | A + 1 |
|:---:|:---:|:---:|
| 0 | 1 | 1 |
| 1 | 1 | 1 |

3. A + A = A

| A | A | A + A |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 1 | 1 |

4. A + ~A = 1

| A | ~A | A + ~A |
|:---:|:---:|:---:|
| 0 | 1 | 1 |
| 1 | 0 | 1 |

5. A • 0 = 0

| A | 0 | A • A |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 0 |

6. A • 1 = A

| A | 1 | A • 1 |
|:---:|:---:|:---:|
| 0 | 1 | 0 |
| 1 | 1 | 1 |

7. A • A = A

| A | 1 | A • A |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 1 | 1 |

8. A • A' = 0

| A | A' | A • A' |
|:---:|:---:|:---:|
| 0 | 1 | 0 |
| 1 | 0 | 0 |

9.  (A')' = A

| A | ~A | (A')' |
|:---:|:---:|:---:|
| 0 | 1 | 0 |
| 1 | 0 | 1 |

10. A+A•B = A•(A+B) = A


- A+A•B = A•(A+B)
```
Prove that,

A+A•B 
= (A+A)•(A+B)   [배분법칙 2번]
= A•(A+B)       [부울규칙 3번]
```
- A+A•B = A
```
Prove that,

A+A•B 
= A•1+A•B   [부울규칙 6번]
= A•(1+B)   [배분법칙 1번]
= A•1       [부울규칙 2번]
= A         [부울규칙 6번]
```

### De Morgan's Theorem

제 1법칙 (1's Theorem)
- (A•B)' = A'+B'
- 변수의 곱에 대한 보수는 각 변수들의 보수의 합과 같다. (드모르간의 제 1법칙)
- NAND게이트는 negative-OR게이트와 등가이다.

| A | B | (A•B)' | A' | B' | A'+B' |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 |

제 2법칙 (2's Theorem)
- (A+B)' = A'•B'
- 변수의 합에 대한 보수는 각 변수들의 보수의 곱과 같다.
- NOR게이트는 negative-AND게이트와 등가이다.

| A | B | (A+B)' | A' | B' | A'•B' |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 0 | 0 |

### NAND와 NOR의 만능 특성
NAND 또는 NOR 는 특이하게도 자신만을 이용해서 다른 모든 논리 게이트를 만들 수 있는 특성이 있다. NAND로만 모든 회로를 만들 수 있고, NAND 회로가 AND 회로보다 크기가 더 작기 때문에 옛날에는 NAND로 모든 회로를 구성했다. NOR 게이트만 사용해도 모든 논리회로를 구성할 수 있다. 하지만, NOR 게이트는 NAND 게이트보다 조금 더 크기 때문에 대부분 NAND를 가장 많이 사용한다. 여기서는 NAND 게이트만 사용하여 다른 논리회로를 만드는 법을 알아본다. NOR 게이트는 NAND를 알면 똑같은 방법을 사용하면 되므로 생략한다.

#### NAND만 사용
Inverter : 같은 입력 값 2개를 NAND게이트에 통과시키면 인버터가 된다. 예를들어, 다음 표와 같이 똑같은 입력 A 2개를 NAND게이트에 넣은 값은 A를 인버터에 통과시킨 것과 같은 결과를 갖는다. (A•B)', (A+B)', A'는 각각 NAND, NOR, 인버터의 베릴로그 표기이다.

| A | A | (A•A)' | A' |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |

이것을 식으로 증명하면, 다음과 같이 나타낼 수 있다.
```
입력 A가 NAND연산만으로 A'가 나와야 NAND게이트만으로 인버터를 만들었다고 할 수 있다.

(A•A)'
= A' + A'   [드모르간 제 1법칙]
= A'        [부울대수 3규칙]

따라서, NAND연산만을 이용해서 A의 인버터 연산을 만들었다.
```

AND : 두 입력값 A,B에 대해서 NAND 게이트를 한 번 통과시킨 후, 그 결과를 2개의 입력으로 하여 다시 NAND게이트에 통과시킨다. 여기서는 진리표는 생략하고 식으로만 증명한다.
```
입력 A와 B가 NAND연산만으로 A•B가 나와야 NAND게이트만으로 AND게이트를 만들었다고 할 수 있다.
NAND로 AND를 만드는 방법은 두 입력값 A,B에 대해서 NAND 게이트를 한 번 통과시킨 후, 그 결과를 2개의 입력으로 하여 다시 NAND게이트에 통과시키는 것이다.

[(A•B)'•(A•B)']'
= [(A•B)']' + [(A•B)']' [드모르간 2법칙]
= (A•B) + (A•B)         [부울대수 9규칙]
= A•B                   [부울대수 3규칙]

따라서, NAND연산만을 이용해서 AND연산을 만들었다.
```

OR : 두 입력값 A,B에 대해서 A와 B를 각각 NAND를 이용해서 ~A, ~B로 만들고 이 값을 다시 NAND 게이트로 통과시키면 된다.
```
A,B를 NAND를 이용하여 A'를 만드는 것은 1번 Inverter를 이용하면 되고, 이 값을 다시 NAND연산하면 된다.

((A'•B')'
= (A')' + (B')' [드모르간 2법칙]
= A+B           [부울대수 9규칙]
```

NOR : 위의 OR게이트의 결과를 NAND 게이트에 통과시키면 된다.
```
NAND로 NOR을 만들기는 3번의 NAND 연산만을 이용하여 OR연산 만든것의 결과를 다시 NAND연산을 하면 된다. 
즉, 3번의 결과인 A+B를 두 개의 입력값으로 하여 NAND연산하면 된다.

((A+B)•(A+B))'
= (A+B)' + (A+B)'
= (A+B)'
```

- XOR : 4개의 NAND 게이트를 이용하면 XOR을 만들 수 있다.

- XNOR : XOR의 결과를 NAND로 만든 인버터에 입력하면 된다.

<br>[Contents](#Contents)<br><br>

## SOP and POS

#### Domain of a Boolean Expression
Domain of a Boolean Expression(부울 식의 영역)은 수식에 사용된 변수들을 말한다.
```
    AB+AC : the domaion is {A,B,C}
    AB+AB'+AC' : the domain is {A,B,C}
```

#### Boolean Addition
부울 덧셈의 경우에는 0이 되는 경우를 찾으면 진리표를 빠르게 완성시킬 수 있다.
| A | B | C | A+B'+C |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 |   |
| 0 | 0 | 1 |   |
| 0 | 1 | 0 |   |
| 0 | 1 | 1 |   |
| 1 | 0 | 0 |   |
| 1 | 0 | 1 |   |
| 1 | 1 | 0 |   |
| 1 | 1 | 1 |   |

A+B'+C가 부울 덧셈이므로 A+B'+C = 0이 되는 A,B,C를 찾으면 A=0, B=1, C=0 한 가지 뿐이다. 따라서, 이 경우를 제외하고 다른 모든 경우에 대해서는 전체 부울수식 A+B'+C의 결과가 1이다.

#### Boolean Multiplication
부울 곱셈의 경우에는 1이 되는 경우를 찾으면 진리표를 빠르게 완성시킬 수 있다.
| A | B | C | AB'C |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 |   |
| 0 | 0 | 1 |   |
| 0 | 1 | 0 |   |
| 0 | 1 | 1 |   |
| 1 | 0 | 0 |   |
| 1 | 0 | 1 |   |
| 1 | 1 | 0 |   |
| 1 | 1 | 1 |   |

AB'C 가 부울 곱셈이므로 AB'C = 1 이 되는 A,B,C를 찾으면 A=1, B=0, C=1 한 가지 뿐이다. 따라서, 이 경우를 제외하고 다른 모든 경우에 대해서는 전체 부울수식 AB'C의 결과가 0이다.

### Sum of Product
`SOP(sum of product)`는 곱의합으로 변수곱의 합으로 이루어진 부울 수식을 말한다. SOP는 AND-OR 로직`(AND게이트를 먼저 통과하고 마지막에 OR게이트를 통과하는 로직)`으로 구현될 수 있으며, 중요한 점은 모든 부울 수식들은 SOP로 변환될 수 있다는 것이다. 즉, 모든 부울 수식들은 정리하면 AND-OR 로직으로 구현할 수 있다.
```
    AB+AC (SOP)
    A'BC+CDE' (SOP)
    
    AB+A(BC)' (SOP 아님, 정리필요)
    = AB+AB'+C'
    = AB+AB'+AC' -> SOP 맞음
```

#### SOP의 진리표
SOP의 경우, 전체 부울 수식이 1이 되는 경우를 찾으면 쉽게 진리표를 완성시킬 수 있다. SOP는 수식이 부울덧셈과 비슷해서 전체 부울 수식이 0이 되는 경우를 찾는 실수를 하기 쉬우므로 주의해야한다. 

`AB+AB'C+ABC'의 진리표를 완성해보자`
| A | B | C | AB+AB'C+ABC' |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 |   |
| 0 | 0 | 1 |   |
| 0 | 1 | 0 |   |
| 0 | 1 | 1 |   |
| 1 | 0 | 0 |   |
| 1 | 0 | 1 |   |
| 1 | 1 | 0 |   |
| 1 | 1 | 1 |   |

```
    [Solution]
    위 식이 SOP이므로, 1이 되는 경우를 생각해보자.
    1) AB=1 이 되면, 다른 항에 상관없이 전체 식이 1이 된다. 즉, A=1, B=1이 되면 전체식은 무조건 1이 된다.
    2) AB'C=1 이 되면, 다른 항에 상관없이 전체 식이 1이 된다. AB'C=1이 되는 경우는 A=1,B=0,C=1인 경우이다.
    3) ABC'=1 이 되면, 다른 항에 상관없이 전체 식이 1이 된다. ABC'=1이 되는 경우는 A=1,B=1,C=0인 경우이다. 
    
    따라서, A=1,B=1인 모든 경우 (A=1,B=1,C=0과 A=1,B=1,C=1) / A=1,B=0,C=1 / A=1,B=1,C=0 인 경우는 1이고 이 경우를 제외하고 다른 모든 경우는 0이다.
```

### Product of Sum
`POS(product of sum)`는 합의곱으로 변수의 합이 곱으로 이루어진 부울 수식을 말한다. POS는 OR-AND 로직`OR게이트를 먼저 통과하고 나중에 AND게이트를 통과하는 로직)`으로 구현될 수 있으며, POS와 SOP는 dual 관계이다.
```
    (A+B)(A') (POS)
    (A'+B')(C'+D) (POS)
```

#### POS의 진리표
POS의 경우, 전체 부울 수식이 0이 되는 경우를 찾으면 쉽게 진리표를 완성시킬 수 있다.

`(A'+B+C')(A'+B'+C)의 진리표를 완성해보자`
| A | B | C | (A'+B+C')(A'+B'+C) |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 |   |
| 0 | 0 | 1 |   |
| 0 | 1 | 0 |   |
| 0 | 1 | 1 |   |
| 1 | 0 | 0 |   |
| 1 | 0 | 1 |   |
| 1 | 1 | 0 |   |
| 1 | 1 | 1 |   |

```
    [Solution]
    위 식이 POS이므로, 0이 되는 경우를 생각해보자.
    1) A'+B+C' = 0 이 되면, 다른 항에 상관없이 전체 식이 0이 된다. A'+B+C'=0이 되는 경우는 A=1,B=0,C=1 이다.
    2) A'+B'+C = 0 이 되면, 다른 항에 상관없이 전체 식이 0이 된다. A'+B'+C=0이 되는 경우는 A=1,B=1,C=0 이다. 
    
    따라서, A=1,B=0,C=1 / A=1,B=1,C=0 인 경우는 0이고 이 경우를 제외하고 다른 모든 경우는 1이다.
```

### SOP와 POS의 상호변환
SOP와 POS는 진리표를 이용해서 서로 쉽게 변환될 수 있다. 예를들어, `A'B'C+AB'C'+ABC`와 등가를 이루는 POS는 무엇일까?
```
    [Solution]
    먼저, 전체 부울수식 A'B'C+AB'C'+ABC 이 POS이므로 전체 수식이 1이 되는 경우를 생각해보자.
    1) A'B'C = 1 -> A=0,B=0,C=1
    2) AB'C' = 1 -> A=1,B=0,C=0
    3) ABC=1 -> A,B,C = 1
    
    이 세 가지 A,B,C를 제외한 나머지 모든 A,B,C에서의 출력 값은 0이다. 이 사실을 토대로 진리표를 완성시키면 다음과 같다. 
    +--------------------+
    | A | B | C | Output |
    +--------------------+
    | 0 | 0 | 0 |    0   |
    +--------------------+
    | 0 | 0 | 1 |    1   |
    +--------------------+
    | 0 | 1 | 0 |    0   |
    +--------------------+
    | 0 | 1 | 1 |    0   |
    +--------------------+
    | 1 | 0 | 0 |    1   |
    +--------------------+
    | 1 | 0 | 1 |    0   |
    +--------------------+
    | 1 | 1 | 0 |    0   |
    +--------------------+
    | 1 | 1 | 1 |    1   |
    +--------------------+
    
    POS의 경우는 전체 부울 식이 0이 되는 경우를 찾는 것이므로 위 진리표에서 출력이 0에 해당하는 A,B,C값이 나오도록 식을 만들면 된다.
    단, POS는 부울 덧셈들의 곱이므로 식은 부울 덧셈 식이 되도록 해야한다.
    1) A=0,B=0,C=0 -> A+B+C
    2) A=0,B=1,C=0 -> A+B'+C
    3) A=0,B=1,C=1 -> A+B'+C'
    4) A=1,B=0,C=1 -> A'+B+C'
    5) A=1,B=1,C=0 -> A'+B'+C

    이제 이 5가지 경우의 식들을 모두 곱해주면 POS가 완성된다.
    (A+B+C)(A+B'+C)(A+B'+C')(A'+B+C')(A'+B'+C)
```

#### 진리표로부터 SOP와 POS 유도
사실 우리는 위에서 SOP를 POS로 변환할 때, 이미 진리표를 보고 POS를 유도하였다. 이를 좀더 공식화해보면 어떤 완성된 진리표가 주어졌을 때, SOP를 유도해내고 싶으면 출력부분이 1인 부분을 보면되고 POS를 유도하고 싶으면 출력부분이 0인 부분을 보면 된다.

`SOP와 POS를 유도해보자`
| A | B | C | Output |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 |

```
    [Solution]
    SOP는 출력이 1인 경우이고, 각 항들이 곱으로 이루어져야 하므로
    1) Output=1, A=0,B=1,C=1 -> A'BC
    2) Output=1, A=1,B=0,C=0 -> AB'C'
    3) Output=1, A=1,B=1,C=0 -> ABC'
    4) Output=1, A=1,B=1,C=1 -> ABC
    이제 나온 모든 항들을 더해준다.
    SOP : A'BC + AB'C' + ABC' + ABC
    
    POS는 출력이 0인 경우이고, 각 항들이 합으로 이루어져야 하므로
    1) Output=0, A=0,B=0,C=0 -> A+B+C
    2) Output=0, A=0,B=0,C=1 -> A+B+C'
    3) Output=0, A=0,B=1,C=0 -> A+B'+C
    4) Output=0, A=1,B=0,C=1 -> A'+B+C'
    이제 나온 모든 항들을 곱해준다.
    POS : (A+B+C)(A+B+C')(A+B'+C)(A'+B+C')
```

이와 같이 진리표를 보고 부울 식을 유도할 수 있다. 하지만, 진리표를 보고 부울식을 유도할 경우 실수할 수도 있고, 무엇보다 식이 완전히 정리되지 않은 상태로 나오게 된다. 이때 카르노 맵을 사용하면 식도 간편하고 실수할 경우도 줄일 수 있다.

<br>[Contents](#Contents)<br><br>

## Karnaugh Map

### Gray Code
그레이 부호란, 수의 크기가 변할 때 인접한 수 사이에 한 자리만 변하게 만들어진 코드를 말한다. 다음 표를 보고 10진코드, 2진코드, 그레이코드를 비교해본다.

`4비트 그레이코드`

| 10진코드 | 2진코드 | 그레이코드 |
|:---:|:---:|:---:|
| 0 | 0000 | 0000 |
| 1 | 0001 | 0001 |
| 2 | 0010 | 0011 |
| 3 | 0011 | 0010 |
| 4 | 0100 | 0110 |
| 5 | 0101 | 0111 |
| 6 | 0110 | 0101 |
| 7 | 0111 | 0100 |
| 8 | 1000 | 1100 |
| 9 | 1001 | 1101 |
| 10 | 1010 | 1111 |
| 11 | 1011 | 1110 |
| 12 | 1100 | 1010 |
| 13 | 1101 | 1011 |
| 14 | 1110 | 1001 |
| 15 | 1111 | 1000 |

위의 표와 같이 그레이 코드는 수가 변할때 인접한 수의 한자리만 변하는 코드이다. 그레이 코드를 사용하는 이유는 순차적인 진행에 유리하다는 점 때문이다. 이진코드의 경우 수가 커지면 여러 개의 비트가 바뀌어야한다. 그에반해, 그레이코드는 인접한 비트 하나만 변경해주면 되기 때문에 값이 순차적으로 증감되는 곳에서 유리하다. 또한, 비트 하나만 변하기 때문에 물리적인 오류에 있어서 여러 비트가 바뀌는 이진코드보다 안전하다는 장점이 있다. 그레이코드는 주로 I/O장치, A/D변환기, 하드디스크 등에 사용된다.

하지만, 그레이코드가 장점만 있는 것은 아니다. 일반적으로 그레이코드는 산술연산에는 사용되지 않는다. 왜냐하면 그레이코드는 이진코드와 달리 가중치가 없기때문에 산술연산을 위해 사용하려면 이진코드로 한번 변환해야한다. 따라서, 코레이코드를 연산이 자주 일어나는 곳에서 사용하는 것은 비효율적이다.

### 카르노 맵
카르노 맵(karnaugh map)은 부울 표현식`(논리식)`을 단순화하는 방법이다. 부울 표현식을 단순화하는 방법은 지난 시간에 배운 Boolean Algebra를 이용하여도 단순화할 수 있다. 하지만, 부울대수를 이용하는 방법은 주어진 식이 복잡한 경우에는 단순화하기 힘들뿐만 아니라 실수할 염려도 있기 때문에 카르노맵을 이용하는 논리식을 단순화하는 것이 일반적이다. 또한, 카르노맵은 여러가지로 응용될 수 있는데 자세한 응용 예제는 [KOCW강의](http://www.kocw.net/home/search/kemView.do?kemId=1319470) 7강 49분을 참고하자.

카르노맵은 변수의 개수에 따라 n변수 카르노맵을 만들 수 있다. 중요한 점은 열과 행을 나타내는 코드들은 `gray code`여야 하며, 각 행 또는 열의 처음과 마지막은 서로 연결되어 있다는 점이다.

`2-변수 카르노맵`

| A \ B | 0 | 1 |
|:---:|:---:|:---:|
| 0 |   |   |
| 1 |   |   |

`3-변수 카르노맵`
| AB \ C | 0 | 1 |
|:---:|:---:|:---:|
| 00 |   |   |
| 01 |   |   |
| 11 |   |   |
| 10 |   |   |

#### 카르노맵을 이용하여 부울식을 단순화하는 방법
```
1. 변수의 개수에 따라 2^n 칸을 갖는 테이블을 만든다.
2. 부울식 SOP, POS에 따라 테이블을 완성시킨다.
3. 규칙에 따라 그룹화한다.
규칙1) 출력이 1인 셀들을 크기는 최대로 하고, 개수는 최소로 하는 직사각형으로 그룹화한다.
규칙2) 단, 크기는 2,4,8,16 ... 처럼 2의 제곱수를 가져야한다.
규칙3) 규칙1,2를 만족시키면서 출력이 1인 모든 셀들을 그룹화해야한다.
4. 그룹을 논리식으로 표현한다.

묶는 방법에 따라 부울식이 다르게 나올 수 있지만, 단순화되는 정도는 똑같기 때문에 상관없다.
```

Example. `X = AB' + AB` 를 단순화해보자

```
[Solution]

M1. 카르노맵을 이용

1) 부울식 X=AB'+AB가 SOP이므로 1이 되는 A,B를 찾고 테이블을 완성시킨다.
AB'=1 -> A=1,B=0
AB=1 -> A=1, B=1
+---+---+---+
|A\B| 0 | 1 |
+---+---+---+
| 0 |   |   |
+---+---+---+
| 1 | 1 | 1 |
+---+---+---+

2) 크기는 최대이고, 개수는 최소로 하도록 1을 직사각형으로 묶는다.
여기서는 A=1,B=0 / A=1,B=1 인 셀 2개를 묶는다.

3) 그룹화 된 직사각형 하나당 SOP항을 하나 만든다.
그룹화 된 직사각형은 1개이며, A=1,B=0 / A=1,B=1 이다. 이것은 A가 1일때, 
B가 어떤값을 갖더라도 출력이 1인 SOP항은 A이다. 

4) 각 항을 묶어서 출력을 표현한다.
여기서 SOP항은 A 1개이므로 출력 X=A 이다.

M2. 부울대수 이용
X = AB'+AB
X = A(B'+B)
X = A

여기서는 주어진 식이 복잡하지 않기때문에 부울대수를 이용한 방법이 더 쉽지만,
식이 조금만 더 복잡해져도 부울대수를 이용하여 단순화하기는 힘들다.
```

Example. 부울식 `X=C'D'+A'BC'D+ABC'D+AB'CD+CD'` 를 단순화해보자
```
[Solution]
1) 테이블 만들기
1. C'D' = 1 -> C=0, D=0 이면 다른값에 상관없이 무조건 1
2. A'BC'D = 1 -> A=0, B=1, C=0, D=1 이면 1
3. ABC'D = 1 -> A=1, B=1, C=0, D=1 이면 1
4. AB'CD = 1 -> A=1, B=0, C=1, D=1 이면 1
5. CD' = 1 -> C=1, D=0 이면 다른값에 상관없이 무조건 1
+-----+-----+-----+-----+-----+
|AB\CD| 0 0 | 0 1 | 1 1 | 1 0 |
+-----+-----+-----+-----+-----+
| 0 0 |  1  |     |     |  1  |
+-----+-----+-----+-----+-----+
| 0 1 |  1  |  1  |     |  1  |
+-----+-----+-----+-----+-----+
| 1 1 |  1  |  1  |     |  1  |
+-----+-----+-----+-----+-----+
| 1 0 |  1  |     |  1  |  1  |
+-----+-----+-----+-----+-----+

2) 직사각형으로 그룹화
1. C=0,D=0 / C=1,D=0 -> 8개의 칸을 갖는 직사각형
2. A=0,B=1,C=0,D=0 / A=0,B=1,C=0,D=1 / A=1,B=1,C=0,D=0 / A=1,B=1,C=0,D=1 -> 4개의 칸을 갖는 직사각형
3. A=1,B=0,C=1,D=1 / A=1,B=0,C=1,D=0 -> 2개의 칸을 갖는 직사각형

3) 직사각형을 SOP로 만들기
1. 8개의 칸을 갖는 직사각형 : A,B,C 값이 0,1 어떤 값을 가져도 상관없고, 오직 D만 0을 가져야 출력이 1이 된다. -> ~D
2. 4개의 칸을 갖는 직사각형 : A는 상관없고, B는 1을 가져야하고, C는 0을 가져야하고, D는 상관없다. -> BC'
3. 2개의 칸을 갖는 직사각형 : A는 1을 가져야하고, B는 0을 가져야하고, C는 1을 가져야하고, D는 상관없다. -> AB'C

4) SOP 전부 합치기
X = D'+BC'+AB'C 로 단순화 할 수 있다.
```

### 무관조건
무관(don't care) 조건이란, 어떤 진리표에서 출력값이 0이거나 1이거나 상관 없는 경우를 말한다. 무관조건은 진리표에서는 x로 표시하고 이것을 그룹화 할 때 1로서 포함해도 되고 0으로서 포함하지 않아도 된다. 그룹화를 할 때, 무관조건들을 포함시켜서 최대 사각형을 만들면 논리식이 훨씬 단순화 된다.

### SOP와 POS 변환
POS `X=(A+B+C)(A+B+C')(A+B'+C)(A+B'+C')(A'+B'+C)`를 SOP로 변환하기
```
1. POS이므로 0이 되는 경우의 수 생각하기
1) A+B+C=0 -> A=0, B=0, C=0
2) A+B+C'=0 -> A=0, B=0, C=1
3) A+B'+C=0 -> A=0, B=1, C=0
4) A+B'+C'=0 -> A=0, B=1, C=1
5) A'+B'+C=0 -> A=1, B=1, C=0
+----+-----+-----+
|AB\C|  0  |  1  |
+----+-----+-----+
| 00 |  0  |  0  |
+----+-----+-----+
| 01 |  0  |  0  |
+----+-----+-----+
| 11 |  0  |  1  |
+----+-----+-----+
| 10 |  1  |  1  |
+----+-----+-----+

2. 직사각형 만들고 POS로 변환하기
1) AB=00, C=0 / AB=00, C=1 / AB=01, C=0 / AB=01, C=1 / AB=11, C=0 -> A
2) AB=01, C=0 / AB=11, C=0 -> (B'+C)
-> POS : A(B'+C)

3. SOP는 위의 테이블에서 출력이 1인 부분으로 직사각형을 만들면 된다.
1) AB=11, C=1 / AB=10, C=1 -> AC
2) AB=10, C=0 / AB=10, C=1 -> AB'
-> SOP : AC+AB'
```

### XOR function
카르노 맵을 보면 XOR도 쉽게 알 수 있다. 아래 테이블에서 출력이 1인 부분의 A,B,C 값의 1의 개수를 세어보면 홀수인 것을 알 수 있다. XOR게이트가 1의 개수가 홀 수 일때만, 1을 출력하는 게이트이므로 일치하는 것을 알 수 있다. 따라서, 아래의 테이블은 논리식으로 `A⊕B⊕C`이다. 아래 테이블을 카르노맵을 이용하여 직사각형으로 묶으려고 하면 오래걸리므로 아래 같은 형태가 나오면 XOR이라는 것을 알아두자.

| AB\C | 0 | `1` |
|:---:|:---:|:---:|
| 00 |   | 1 |
| `01` | 1 |   |
| `11` |   | 1 |
| `10` | 1 |   |

### 5-변수 카르노맵
변수가 5개인 논리식에 대해서도 카르노맵을 만들 수 있다. 이 경우에는 A=0, A=1 일때 B,C,D,E를 갖는 4-변수 카르노맵 2개를 만들어서 사용한다. 자세한 방법은 링크에 있는 [KOCW강의](http://www.kocw.net/home/search/kemView.do?kemId=1319470) 7강 48분을 참고하자.

<br>[Contents](#Contents)<br><br>

 ## Logic Circuit
 논리회로란, 논리 값을 결정짓는 연산회로를 말한다. 논리회로는 논리게이트 및 플립플롭으로 구성되며, 논리회로의 신호는 [부울대수](#Boolean-Algebra)에 의존한다.

 #### 논리연산, 논리소자, 논리회로
 - 논리연산 (logic operation) : 하나 이상의 논리값으로 부터 새로운 논리값을 얻는 연산
 - 논리소자 (logic gate, logic element) : 기본 [회로소자](#Circuit-Element)들을 조합하여 논리연산을 물리적으로 구현한 것
 - 논리회로 (logic circuit) : 논리값을 결정하는 연산회로, 논리소자 및 플립플롭으로 구성

 #### 논리회로의 종류
 - 조합논리회로 (Combinational Logic Circuit) : 오직 현재의 입력 상태에 의해서만 출력논리가 결정되는 회로, 기억소자가 없고 [논리게이트](#Logic-Gate)만으로 구성된다.
 - 순차논리회로 (Sequential Logic Circuit) : 현재의 입력 및 과거의 입력/출력 신호 등 모두에 의해서 출력논리가 결정되는 회로, 즉, 메모리 요소(상태저장)을 가지고 있다.

 #### 논리회로의 설계 과정
 - 요구사항 -> 진리표 -> 논리식 -> 논리식 단순화 -> 논리회로 설계

 ## Combinational Logic Circuit
 오직 현재의 입력 상태에 의해서만 출력논리가 결정되는 회로, 기억소자가 없고 여러 개의 [논리게이트](#Logic-Gate)만으로 구성된다.

 ### Adder
가산기는 두 오퍼랜드를 더하는 조합논리회로를 말한다. 가산기 중에는 반가산기와 전가산기가 있다. 컴퓨터에서는 감산기는 없으므로 보수를 취해서 더하는 방식으로 뺄셈을 구현한다.
 
 #### Half Adder
 Half Adder(반가산기)는 2개의 1비트를 더하여 sum과 carry를 발생시키는 가산기

`1. 반가산기 진리표`

| A | B | sum | carry |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

`2. 반가산기 진리표를 보고 논리식 만들기(카르노맵)`

[sum]
|A\B| 0 | 1 |
|:---:|:---:|:---:|
| 0 |   | 1 |
| 1 | 1 |   |

-> sum = AA'+A'B = A⊕B

[carry]
|A\B| 0 | 1 |
|:---:|:---:|:---:|
| 0 |   |   |
| 1 |   | 1 |

-> carry = AB

`3. 회로로 만들기`

sum은 XOR게이트, carry는 AND게이트 사용하여 연결

#### Full Adder
전가산기는 3개의 비트(A,B,C<sub>in</sub>)를 더하여 sum과 carry를 발생시킨다. C<sub>in</sub>은 전 단에서 올라온 carry를 말한다.

#### 전가산기의 논리식
- sum = A⊕B⊕C<sub>in</sub>
- carryt out = AB+(A⊕B)C<sub>in</sub> = AB+AC<sub>in</sub>+BC<sub>in</sub>

#### 전가산기의 논리회로
전가산기는 2개의 반가산기와 OR게이트 하나로 만들 수 있다.

#### 4비트 가산기
- 4비트 가산기는 가산기 중 사용하는 게이트 수가 가장 적은 간단한 구조이지만, 캐리의 전파시간 때문에 가장 느리다.
- 지연시간은 n비트 가산기인 경우, 2n 또는 2n+2이다. `32비트 가산기의 지연시간 = 64 또는 66`  
- RCA(ripple carry adder)라고도 한다.

### Comparator
비교기(Comparator)는 두 수의 크기에 따라 같다,크다,작다의 3가지 상태를 출력하는 조합논리회로이다.

#### 비교기의 논리식
- equal = (A⊕B)' (XNOR게이트)
- greater = AB'
- less = A'B

### Decoder & Encoder
디코더는 n비트 이진코드를 2<sup>n</sup>개의 서로다른 출력으로 만들어주는 논리회로를 말한다. 인코더는 디코더의 반대로, 개별적인 입력을 코드화해서 이진코드로 만들어주는 논리회로이다. 

예를들어, CPU와 키보드, 모니터, 마우스, 모뎀, ... 등 8개의 주변장치를 연결한다고 생각해보자. 디코더가 없으면 CPU에 8개의 주변장치를 하나씩 연결하는 신호선을 만들어야한다. 하지만 CPU와 8개의 주변장치 중간에 디코더를 하나 두고 이 디코더와 다른 주변장치를 연결한다고 생각해보자. 그렇다면 CPU는 총 3개의 이진코드 신호선만 연결하면 된다. CPU가 3개의 신호선으로 디코더에게 이진코드를 건네주면 디코더는 이 코드를 해석하여 알맞은 주변장치를 연결해주면 된다. 

`000->디코더->키보드(0번), 010->디코더->마우스(2번), 111->디코더->모뎀(7번)`

### Multiplexer
여러 개의 입력 중 하나를 선택하여 출력으로 내보내는 조합논리회로로 일종의 데이터 선택기이다. 입력의 개수에 따라 2-to-1, 4-to-1, .. 등이 있다. Mux라고도 한다.

### Demultiplexer
1개의 입력을 2<sup>n</sup>개의 출력선 중 하나로 내보내는 조합논리회로로 일종의 데이터 분배기이다. 출력선의 개수에 따라 1-to-2, 1-to-4, ..등이 있다. DeMux라고도 한다.

### Parity
패리티는 디지털 신호 전송 시 전송 데이터에 1비트를 추가로 더 보내어 수신측에서 오류를 체크할 수 있게 해주는 조합논리회로이다.

<br>[Contents](#Contents)<br><br>

## Sequential Logic Circuit
현재의 입력 및 과거의 입력/출력 신호 등 모두에 의해서 출력논리가 결정되는 회로, 값을 저장하기 위한 래치, 플립플롭, 레지스터, 메모리 등의 소자로 현재 상태를 저장한다.

### SR Latch
- S(set)가 0일 때 1을 출력, R(reset)이 0일 때 0을 출력, 둘다 1일때는 기존값 유지
- S,R을 둘 다 0으로 설정하는 경우에는 출력값을 예측할 수 없으므로 허용되지 않는다.
- 기계적인 진동에 의한 contact bounce 오류를 제거하기 위해 사용된다.

### Gated SR Latch
- EN(enable)신호가 있는 SR 래치
- EN=0이면 SR래치의 입력값이 1,1 이므로 기존값 유지, EN=1이면 입력이 not되어 출력값이 변할 수 있다.
- S,R이 1일 때 활성화되므로 `active-high` 신호이다.
- EN=1이고, S,R이 각각 1이면 다음 SR 래치에서 S,R이 각각 0,0이 되므로 허용될 수 없는 값이 나온다.

### D Latch
- Gated SR Latch의 입력 하나를 인버터로 묶어서 허용되지 않는 값 입력으로 들어갈 수 없도록 만든 래치
- 일반적으로 가장 많이 사용되는 래치이다. (보통 래치라고 하면 이 D래치를 말한다.)
- EN=1이면, 출력 Q는 입력 D값을 그대로 출력하므로 `trasparent latch` 라고도 한다. 

#### Clock 신호
- clock 신호는 주기적인 square wave이다.
- 의미있는 정보를 보내는 것이 아니고 타이밍을 맞추기 위해 사용한다. 
- Clock 신호에 맞추어 래치나 플립플롭들이 동시에 정보를 저장한다.

### Flip-Flops
- clock 신호가 변화하는 시점(edge)에 맞추어 동작 `(edge-sensitive)`
- 반면에, latch는 clock 신호 값에 맞추어 동작 `(level-sensitive)
- 상승/하강 edge 중 동작하는 edge에 따라 rising edge triggered F/F, falling edge triggered F/F가 있다.

### D F/F
- 전통적인 D rising edge triggered F/F이다.
- C(clock)=0이면, S,R=1이 되므로 기존값 유지
- C=0->1로 바뀌는 순간에 D=0의 입력값을 주면 SR래치에 S=1,R=0이므로 Q=0(비활성화)된다.
- C=0->1로 바뀌는 순간에 D=1의 입력값을 주면 SR래치에 S=0,R=1이므로 Q=1(활성화)된다.
- 따라서, C=0,C=1 일 때는 작동하지 않고(기존값을 유지), C=0->1로 바뀌는 순간에 D값에 따라 Q 값을 출력한다.

### JK F/F
- 카운터를 만들때 유용한 플립플롭
- 

## Reference
- [KOCW 강의 - 디지털 논리 회로 익히기](http://www.kocw.net/home/search/kemView.do?kemId=1319470)
- [정보통신기술용어해설](http://www.ktword.co.kr/abbr_view.php?nav=2&id=124&m_temp1=4893)
- [Wikipedia - floating point arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)
- [Wikipedia - Logic Gate](https://en.wikipedia.org/wiki/Logic_gate)
- [Wikipedia - Verilog](https://en.wikipedia.org/wiki/Verilog)
- [Wikipedia - Bool Algebra](https://en.wikipedia.org/wiki/Bol_loop)


