# Digital Logic

## Contents

- Ch 1 : [Introduction](#Introduction)
    - [아날로그와 디지털](#아날로그와-디지털)
    - [아날로그 신호를 디지털 신호로 변환하는 방법](#아날로그-신호를-디지털-신호로-변환하는-방법)
    - [디지털시스템의 장점](#디지털시스템의-장점)
- Ch 2 : [Number System](#Number-System)
    - [컴퓨터가 수를 표현하는 방법](#컴퓨터가-수를-표현하는-방법)
    - [이진수의 연산](#이진수의-연산)
    - [Floting-point number](#Floting-point-number)
- Ch 3 : [Logic Gate](#Logic-Gate)
    - [Buffer](#Buffer)
    - [Inverter](#Inverter)
    - [AND](#AND)
    - [OR](#OR)
    - [NAND](#NAND)
    - [NOR](#NOR)
    - [XOR](#XOR)
    - [XNOR](#XNOR)
- Ch 4 : [Boolean Algebra](#Boolean-Algebra)
    - []

## Introduction

### 아날로그와 디지털 ###
아날로그 양(Analog Quantities)은 시간에 따라 연속적으로 변화하는 값을 말한다. 온도, 습도, 소리과 같이 우리 주변에서 볼 수 있는 대부분의 자연현상들이 이 아날로그에 속한다. 디지털 양(Digital Quantities)은 아날로그 양과 반대되는 개념으로 이산적인(discrete) 값을 말한다.

### 아날로그 신호를 디지털 신호로 변환하는 방법 ###
아날로그 신호를 디지털 신호로 변환하기 위해서는 표본화(Sampling), 양자화(Quantizing), 부호화(Encoding)를 거쳐야한다. 0시부터 24시까지의 시간-온도 그래프를 디지털 값으로 변환한다고 생각해보자.
연속적인 값을 불연속적인 디지털 값으로 만들기위해 0시부터 24시까지 연속적인 시간을 특정 시간을 기준으로 나눈 후, 해당 시간에 맞는 표본값을 추출해야하는데 이러한 과정을 표본화라고 할 수 있다.
표본화 된 데이터 값은 32.211, 4.0911...과 같이 아직 연속적인 값을 갖는다. 이러한 값을 컴퓨터가 나타낼 수 있는 최대 정확도의 값으로 근사화 시켜야하는데 이것을 양자화라고한다. 부호화란, 표본화와 양자화를 마친 데이터를 0과 1로 이루어진 이진수로 변환하는 과정이다. 아날로그 신호를 디지털 신호로 변환하는 과정 중 표본화와 양자화 과정에서는 데이터의 손실이 일어난다.

### 디지털시스템의 장점 ###
그렇다면 아날로그보다 정확도가 떨어지는 디지털 시스템을 왜 사용할까? 디지털 시스템을 사용하는 이유에는 다음 몇 가지가 있다.  
1. 0과 1만 디지털 신호로 사용하기 때문에 외부 환경(열이나 잡음)에 강하다.
2. 0과 1만 사용하기 때문에 데이터의 저장이나 가공이 간편하다.
3. 연속적인 전기신호를 0과 1로만 표현하기 때문에 시스템 설계가 간편하다. 

### 이진값과 전압 ###
연속적인 전기 신호를 어떻게 불연속적인 0과 1의 논리데이터로 나타낼 수 있을까? 일반적으로 Positive Logic으로 전압이 기준값보다 낮을 때는 0, 높을때는 1의 값을 갖도록 하는 것이다. 이 때, 0에서 1로 올라가는 부분을 상승엣지라고 부르고 그 반대를 하강엣지라고 한다. 실제로는 상승과 하강은 바로 일어나지는 않고 어느정도 시간을 두고 발생한다.

### 주기와 주파수 ###
주기란, 상승(하강)엣지부터 다음 상승(하강)엣지까지를 말하며 단위는 초이다. 주파수는 1초에 진동하는 횟수를 말하며 단위는 Hz이다. 예를들어 1초에 1000번 진동하는 신호는 주파수가 1000Hz라고 할 수 있다.
- Period (T) : seconds
- Frequency (f) : Hertz (cycles per second)
- T = 1 / f 

### 논리회로의 종류 ###
1. 조합논리회로 (combinational logic circuit) : 기본 게이트의 조합으로 구성되는 회로 `ex) 리모컨의 숫자 버튼`
2. 순차논리회로 (sequential logic circuit) : 플립플롭(flip-flop) 등 현재 상태를 저장하는 저장소자가 포함된 논리회로 `ex) 리모컨의 채널 +/- 버튼`

### 저장소자의 종류 ###
- Latch, Flip-flop
- Register (플립플롭이 여러개 모인 것)
- 메모리 : (공통점)전원을 끄면 저장되어 있던게 사라지는 휘발성 메모리
    - DRAM (dynamic random access memory) : 저장된 데이터가 시간이 지나면 사라지는 메모리, 주기적 Refresh를 해주지 않으면 데이터가 사라진다. SRAM보다 속도도 느리지만 가격이 저렴하기 때문에 컴퓨터의 주 메모리로 사용한다.
    - SRAM (static random access memory) : Refresh를 하지 않아도 데이터가 사라지지 않는 메모리, 캐시 메모리로 사용한다.

<br>[Contents](#Contents)<br><br>

## Number System
컴퓨터공학에서 중요하게 알아야 할 2진수와 16진수가 있다. 2진수의 digit은 0과1, 16진수의 digit은 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F이다. 2진수와 16진수는 4비트 단위로 변환될 수 있다. 

ex) 0111<sub>(2)</sub> = 7<sub>(16)</sub> , 1111<sub>(2)</sub> = F<sub>(16)</sub>

BCD (binary coded decima)
십진수의 각 자리 수를 4비트의 2진수로 표현한 것을 말한다. BCD의 덧셈도 있는데 구글링하면 쉽게 찾을 수 있으므로 여기서는 다루지 않는다.

ex) 35<sub>(10)</sub> = (0011 0101)<sub>BCD</sub>, (0001 0111 0000)<sub>BCD</sub> = 170<sub>(10)</sub>

#### MSB and LSB
- MSB (most significant bit) : 가장 왼쪽에 있는 비트
- LSB (least significant bit) : 가장 오른쪽에 있는 비트

### 컴퓨터가 수를 표현하는 방법
0과 1로 이루어진 이진수는 컴퓨터가 의미를 구분할 수 있는 전류가 흐르냐/흐르지 않냐와 대응되기 좋고, 디지털 시스템의 장점때문에 컴퓨터가 사용하기 좋은 수 체계이다. 십진수를 이진수로 변환하거나 이진수를 십진수로 변환하는 쉽고 검색해보면 많이 나오기 때문에 여기서는 다루지는 않겠다.

#### 이진수의 음수 변환의 필요성
컴퓨터는 이진수로 수를 나타낸 다는 것을 알았다. 컴퓨터는 이진수 체계를 이용하여 데이터를 저장하고, 사칙연산을 하여 데이터를 가공하기도 한다. 컴퓨터가 덧셈을 할 때는 가산기(Adder)라는 논리회로(logic gate)를 통해서 덧셈을 한다. 그런데 만약 컴퓨터가 뺄셈을 하려고 한다면 뺄셈기라는 회로를 또 만들어주어야할까? 또는 곱셈이나 나눗셈을 한다고 했을 때 각각의 회로를 하나씩 만드는건 큰 낭비가 될 수가 있다. 따라서 사실 컴퓨터는 모든 사칙연산을 가산기 하나만으로 해결한다. 예를 들어 뺼셈의 경우에는 39 - 20 은 39 + (-20) 과 같이 해결하고 곱셈과 나눗셈의 경우 다음과 알고리즘에 의해 자리수를 맞춰주고 가산기로 다 더해서 계산한다.

[컴퓨터가 곱셈/나눗셈을 하는 원리](https://blackinkgj.github.io/AL/)

따라서 컴퓨터는 이제 이진수를 음수로도 표현해야 한다. 사람의 경우 앞에 부호만 붙여주면 되지만 컴퓨터는 모든 수를 0과1로 구분하기 때문에 - 부호를 인식할 방법이 없다. 이러한 문제를 해결하기 위해 이진수를 음수로 표현하는 몇 가지 방법이 있는데 다음과 같다.

1. Sign-magnitude (부호와 절대값) : msb는 부호를 담당하고, 나머지 비트는 절대값을 담당하는 방법
2. 1's complement (1의 보수) : 모든 비트를 반전시켜 음수를 표현하는 방법
3. 2's complement (2의 보수) : 1의보수에 1을 더해서 음수를 표현하는 방법

예를들어, -39를 8비트로 각각의 방법으로 표현해보자.
1. Sign-magnitude : 십진수 39를 8비트 이진수로 나타내면 00100111이므로 sign-magnitude로 음수를 표현하면, 10100111이다.
2. 1's complement : 십진수 39는 00100110 이고, 모든 비트를 반전시켜 -39를 11011000로 표현한다.
3. 2's complement : 1의보수에 1을 더해서 표현한다. 11011001

주의할 점은, 십진수 39를 8비트 칸의 이진수로 변환할 때는 방법이 하나밖에 없기 때문에 00100111밖에 없다. 하지만, 십진수 -39를 이진수로 변환할 때는 방법이 3가지가 있기 때문에 각 방법에 따라 다르게 표현된다. 다행히도 이 세가지 방법 중 2의 보수 체계가 다른 방법보다 월등히 좋기 때문에 컴퓨터는 특별한 일이 없는 이상은 2의 보수 체계를 사용한다. 2의 보수가 음수를 표현하는데 있어서 다른 방법보다 좋은 이유는 다음과 같다.

| Sequence | 2의보수 | 1의보수 | 부호와절대값 |
|:---:|:---:|:---:|:---:|
| 0111 | 7 | 7 | 7 |
| 0110 | 6 | 6 | 6 |
| 0101 | 5 | 5 | 5 |
| 0100 | 4 | 4 | 4 |
| 0011 | 3 | 3 | 3 |
| 0010 | 2 | 2 | 2 |
| 0001 | 1 | 1 | 1 |
| 0000 | 0 | 0 | 0 |
| 1111 | -1 | -0 | -7 |
| 1110 | -2 | -1 | -6 |
| 1101 | -3 | -2 | -5 |
| 1100 | -4 | -3 | -4 |
| 1011 | -5 | -4 | -3 |
| 1010 | -6 | -5 | -2 |
| 1001 | -7 | -6 | -1 |
| 1000 | -8 | -7 | -0 |

위 표와 같이 1의 보수와 부호와 절대값은 0이 두 개가 생기는 문제가 발생하며, 부호와 절대값 방법은 수의 순서가 자연스럽지 않기 때문에 컴퓨터는 음수 표현 방법으로써 2의 보수를 사용한다. 이제 컴퓨터가 이진수 체계를 사용하며, 음수의 경우에는 2의 보수로 음수를 표현한다는 것을 알았다. 하지만, 아직 정리되지 않은 부분이 있다. 만약, 4비트 칸을 가진 이진수 1111을 십진수로 변환한다고 했을 때, 답이 15도 되고, -1도 되어버린다는 문제가 있다.
따라서, 이진수를 표현할때는 반드시 부호가 있는지 없는지(signed/unsigned)를 명시해주던가 아니면 컴퓨터가 2의보수로 음수를 표현하므로 2의보수 1111인지를 명시해줘야한다. 이것이 우리가 프로그래밍 언어에서 signed와 unsigned가 존재하는 이유이다.

즉, 위의 문제를 다시 올바르게 표현하면 "4비트 칸을 가진 signed 1111을 십진수로 변환하라." 혹은 "2의보수 1111을 십진수로 변환하라." 가 된다.

정리를 해보자면,
1. 십진수 39를 이진수로 변환 (8비트) : 우리가 평소알던 방법대로 변환하면 된다. -> 39 = 00100111
2. 십진수 -39를 이진수로 변환 (8비트) : 이진수를 음수로 표현하기 위해 2의보수로 -39를 표현하면 된다. 즉, 39의 이진수에 1의보수를 취하고 1을 더한다. 그리고, 원래 십진수가 -39였기 때문에 signed를 해주던가 2의보수인지를 알려준다. -> 39 -> 00100111 -> 11011000 -> 11011001 -> signed 11011001 or 2의보수 11011001
3. signed 11011001(혹은 2의보수 11011001)를 십진수로 변환 : msb만 음수로 계산한다. -> 2<sup>7</sup> * (-1) + 2<sup>6</sup> * 1 + 2<sup>5</sup> * 0 + 2<sup>4</sup> * 1 + 2<sup>3</sup> * 1 + 2<sup>2</sup> * 0 + 2<sup>1</sup> * 0 + 2<sup>0</sup> * 1 = -39
    - signed 01011001인 경우는 -> 2<sup>7</sup> * (0) + 2<sup>6</sup> * 1 + 2<sup>5</sup> * 0 + 2<sup>4</sup> * 1 + 2<sup>3</sup> * 1 + 2<sup>2</sup> * 0 + 2<sup>1</sup> * 0 + 2<sup>0</sup> * 1
    - 즉, signed 이진수에서는 msb가 부호를 결정한다. 1이면 음수, 0이면 양수
4. unsigned 11011001을 십진수로 변환하기 : unsigned이므로 평소 방법대로 하면 된다. 즉, 1번 방법을 거꾸로 하면된다. -> unsigned 11011001 -> 217

### 이진수의 연산
이진수의 덧셈은 unsigned와 signed 이진수를 다르게한다. unsigned 이진수의 덧셈은 일반 덧셈과 똑같이 한다. signed 이진수 덧셈은 unsigned와 똑같이 하는데 마지막에 발생하는 carry는 무조건 버려야한다.
```
     <unsigned 이진수의 덧셈>                   <signed 이진수의 덧셈>
                                           
       00001111       15                      00001111       15
     + 11111010    + 250                    + 11111010    + (-6)
     -------------------                    --------------------
      100000001      265                      00001001        9      [100001001 이지만, unsigned 이진수 덧셈이므로 마지막 캐리는 버려야한다.]
```

이진수의 뺄셈은 unsigned나 signed나 똑같다. - 부호를 가진 수(subtrahend)를 2의보수로 변환해서 더하면 된다.
```
     <이진수의 뺄셈>
     
     ex) 15 - 32 = -17
     
     15 - 32 = 15 + (-32) 이고, 이것을 이진수로 변환하면
     00001111 + 11011111 = 11101110 이다.
     11101110 = -17 이므로 연산결과가 옳다.
```

#### signed 이진수의 오버플로우(overflow)
singed 이진수의 덧셈에서 수의 표현범위를 벗어나는 오버플로우 현상이 일어나는데 그 예는 다음과 같다. 따라서, 양수+양수=음수이거나 음수+음수=양수가 되면 signed 이진수의 연산에서 오버플로우가 발생했다는 것을 알 수 있다.
```
     <양수 + 양수 = 음수가 되는 경우>                  <음수 + 음수 = 양수가 되는 경우>
        
        01111111   (127)                           10000000   (-128)
      + 00000001     (1)                         + 11111111     (-1)
      ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                      --------------------
        10000000  (-128)                           01111111    (127)    [101111111 이지만, unsigned 이진수 덧셈이므로 마지막 캐리는 버려야한다.]
``` 

#### unsigned 이진수의 오버플로우
unsigned 이진수의 경우에는 유효범위를 넘어가면 오버플로우가 발생한다. 예를들어 8비트의 이진수를 생각해보자. 8비트 unsigned 이진수의 경우 유효범위는 0~255이다.
```
     <유효범위를 벗어나지 않음>                         <유효범위를 벗어난 경우>
       
       01010110     (86)                           11010110     (214)
     + 01110101   + (117)                        + 01110101   + (117)
     ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                      ---------------------
       11001011     (203)                          01001011      (75)    [101001011 이지만, 8비트이기 때문에 앞의 1을 표현할 비트 자리가 부족]
```

### Floating-point number
floating-point number는 실수를 컴퓨터상에서 근사값으로 표현할 때 소수점의 위치를 고정하지 않고, 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 Significant(가수)와 소수점의 위치를 풀이하는 Exponent(지수)로 나누어 표현한다. 예전에는 부동소수점 표준이 굉장히 많았지만 현재는 IEEE754 Standards에서 제시한 Single precision(단정도), Double precision(배정도) 두 포맷이 쓰인다. c언어에서 32비트를 쓰는 float 이 Single precision이고 64비트를 사용하는 double이 double precision이다.

```
                  <Single Precision>
    +------+--------------+-------------------------+
    | S(1) |     E(8)     |          f(23)          |
    +------+--------------+-------------------------+
    
                       <Double Precision>
    +------+------------------+------------------------------+
    | S(1) |       E(11)      |             f(52)            |
    +------+------------------+------------------------------+
```

각각의 값은 다음과 같이 표기된다. 부동소수점의 원리는 복잡하므로 여기서는 표기법만 알아본다.
- Single Precision : F = (-1)<sup>S</sup> x 1.f x 2<sup>E-127</sup>
- Double Precision : F = (-1)<sup>S</sup> x 1.f  x 2<sup>E-1203</sup>

<br>[Contents](#Contents)<br><br>

## Logic Gate
Logic Gate(논리회로)는 Boolean Algebra를 물리적 장치에 구현한 것으로, 하나 이상의 논리적 입력값에 대해 논리 연산을 수행하여 하나의 논리적 출력값을 얻는 물리적 전자장치의 이상적인 모델을 말한다. Boolean Algebra란, 어떤 명제의 참과 거짓을 이진수 1과 0에 대응시켜서 명제와 명제간의 관계를 수학적으로 표현하는 것이다. 고전 명제 논리의 명제의 격자와 같은 성질을 갖는 격자이다. 즉 논리적 공리들을 만족시키는 논리합과 논리곱 및 부정의 연산이 정의된 대수 구조이다. 

기본 논리게이트의 종류로는 Buffer, Inverter, AND, NAND, OR, NOR, XOR, XNOR 등이 있다. Buffer, Inverter는 입력값이 하나인 1-input Gate이다.

#### Verilog
IEEE 1364로 표준화 된 Verilog는 전자 시스템을 모델링하는 데 사용되는 하드웨어 설명 언어 (Hardware Description Language)입니다. 레지스터 전송 추상화 수준에서 디지털 회로의 설계 및 검증에 가장 일반적으로 사용됩니다. 여기서는 논리회로를 표현할 때 베릴로그 표기법 사용한다. 부울 표기법과 심볼들은 링크를 첨부해두었다.

### Buffer
버퍼는 입력과 출력이 같은 논리게이트이다.

[심볼, 부울대수 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Verilog Equation : Q = A

Truth table
| Input | Output |
|:---:|:---:|
| A | X | 
| 0 | 0 |
| 1 | 1 |

### Inverter
입력을 반전하여 출력하는 논리게이트이다. NOT이라고도 한다. 1의보수 발생기로 응용할 수 있다. 

[심볼, 부울대수 보기](https://en.wikipedia.org/wiki/Logic_gate)

- Verilog Equation : Q = ~A

Truth table
| Input | Output |
|:---:|:---:|
| A | X | 
| 0 | 1 |
| 1 | 0 |

### AND
두 수의 입력이 모두 1일 경우에만 출력이 1인 논리게이트이다. AND 게이트는 0 • 0 = 0, 0 • 1 = 0, 1 • 0 = 0, 1 • 1 = 1이 되는 성질 때문에 `논리곱(Conjunction)`이라고 불린다. AND 게이트는 신호를 Masking하는데 사용된다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

- Verilog Equation : X = A & B

Truth table
| Input | Output |
| A | B | Q |
|:---:|:---:|:---:|
| 0 | 0 | 0 |
| 1 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

### OR
두 수의 입력 중 하나라도 1인 경우에 출력이 1 또는 두 수의 입력이 모두 0일 경우에만 0인 논리게이트를 말한다. 0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, 1 + 1 = 1이 되는 성질 때문에 `논리합(Disjunction)`이라고 불린다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

-  Verilog Equation : X = A | B

### NAND
두 수의 입력이 1일 경우에만 출력이 0인 논리게이트이다. AND의 출력을 NOT 시킨 것과 같다. NAND 게이트는 negative-OR 게이트와 등가이다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

-  Verilog Equation : X = ~ ( A & B )

### NOR
두 수의 입력 중 하나라도 1인 경우에 출력이 0 또는 두 수의 입력이 모두 0일 경우에만 출력이 1인 논리게이트를 말한다. OR의 출력을 NOT 시킨 것과 같다. NOR 게이트는 negative-AND 게이트와 등가이다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

-  Verilog Equation : X = ~ ( A | B )

### XOR
Exclusive-OR의 줄임말로 두 수가 다를 때 출력이 1 또는 1의 개수가 홀수일 때 출력이 1인 논리게이트를 말한다. 1의 개수가 홀수일 때 1을 출력하므로 홀수(Odd) 함수라고도 한다. 또한, 두 수가 다를 때 1을 출력하는 특징 때문에 인공위성이나 항공기 등과 같이 매우 중요한 회로에 쓰이는데, 입력에 똑같은 A회로 2개를 놓고 2개의 회로가 서로 다르게 들어오면 오류를 출력하도록 만들 수 있다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

-  Verilog Equation : X = A ^ B

### XNOR
Exclusive-NOR의 줄임말로 두 수가 같을 때 출력이 1 또는 1의 개수가 짝수일 때 출력이 1인 논리게이트를 말한다. 1의 개수가 짝수일 때 1을 출력하므로 짝수(Even) 함수라고도 한다. XNOR는 XOR의 NOT과 같다.

[심볼, 진리표, 부울대수 보러가기](https://en.wikipedia.org/wiki/Logic_gate)

-  Verilog Equation : X = ~ ( A ^ B )

<br>[Contents](#Contents)<br><br>

## Boolean Algebra
부울 대수(boolean algebra)는 어떤 명제의 참과 거짓을 이진수 1과 0에 대응시켜서 명제와 명제간의 관계를 수학적으로 표현하는 것이다. 논리적 공리들을 만족시키는 논리합과 논리곱 및 부정의 연산이 정의된 대수 구조이다. 부울 대수의 법칙들에는 교환법칙, 결합법칙, 배분법칙이 있다.

#### 교환법칙 (Commutative Law)
- 부울 합 (OR) : A+B = B+A
| A | B | A+B | B+A |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 |

- 부울 곱 (AND) : A•B = B•A
| A | B | A•B | B•A |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 |

#### 결합법칙 (Associative Law)
- A+(B+C) = (A+B)+C
- A•(B•C) = (A•B)•C

#### 배분법칙 (Distributive Law)
- A•(B+C) = (A•B)+(A•C)
| Input | A•(B+C) | (A•B)+(A•C) |
|:---:|:---:|:---:|:---:|
| A | B | C | B+C | A•(B+C) | (A•B)+(A•C) 
| 0 | 0 | 0 | 0 | 0 | 0 | 
| 1 | 0 | 0 | 0 | 0 | 0 | 
| 0 | 1 | 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 | 0 |
| 1 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 1 | 1 | 1 |
| 0 | 1 | 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 1 | 1 | 1 |

- A+(B•C) = (A+B)•(A+C)
| Input | A+(B•C) | (A+B)•(A+C) |
|:---:|:---:|:---:|:---:|
| A | B | C | B•C | A+(B•C) | (A+B)•(A+C) 
| 0 | 0 | 0 | 0 | 0 | 0 | 
| 1 | 0 | 0 | 0 | 1 | 1 | 
| 0 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 0 | 0 |
| 1 | 1 | 0 | 0 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 |

### 부울대수의 규칙
1. A + 0 = A
| Input | Output |
|:---:|:---:|:---:|
| A | 0 | A + 0 |
| 0 | 0 | 0 |
| 1 | 0 | 1 |

2. A + 1 = 1
| Input | Output |
|:---:|:---:|:---:|
| A | 1 | A + 1 |
| 0 | 1 | 1 |
| 1 | 1 | 1 |

3. A + A = A
| Input | Output |
|:---:|:---:|:---:|
| A | A | A + A |
| 0 | 0 | 0 |
| 1 | 1 | 1 |

4. A + \bar{A} = 1
| Input | Output |
|:---:|:---:|:---:|
| A | \bar{A} | A + \bar{A} |
| 0 | 1 | 1 |
| 1 | 0 | 1 |

5. A \cdot 0 = 0
| Input | Output |
|:---:|:---:|:---:|
| A | 0 | A \cdot A |
| 0 | 0 | 0 |
| 1 | 0 | 0 |

6. A \cdot 1 = A
| Input | Output |
|:---:|:---:|:---:|
| A | 1 | A \cdot 1 |
| 0 | 1 | 0 |
| 1 | 1 | 1 |

7. A \cdot A = A
| Input | Output |
|:---:|:---:|:---:|
| A | 1 | A \cdot A |
| 0 | 0 | 0 |
| 1 | 1 | 1 |

8. A \cdot \bar{A} = 0
| Input | Output |
|:---:|:---:|:---:|
| A | \bar{A} | A \cdot \bar{A} |
| 0 | 1 | 0 |
| 1 | 0 | 0 |

9. \bar{\bar{A}} = A
| Input | Output |
|:---:|:---:|:---:|
| A | \bar{A} | \bar{\bar{A}} |
| 0 | 1 | 0 |
| 1 | 0 | 1 |

10. A+A\cdotB = A\cdot(A+B) = A
A+A\cdotB = (A+A)\cdot(A+B) = A\cdot(A+B)

(A\cdot1)+(A\cdotB) = A\cdot(1+B) = A\cdot1 = A

### 드모르간의 정리 (De Morgan's Theorem)

#### 제 1법칙 (1's Theorem)
- \bar{AB} = \bar{A} + \bar{B}
- 변수의 곱에 대한 보수는 각 변수들의 보수의 합과 같다. (드모르간의 제 1법칙)
- NAND게이트 (\bar{AB}) = negative-OR게이트 (\bar{A}+\bar{B})
| Input | Output | Output |
|:---:|:---:|:---:|
| A | B | \bar{AB} | \bar{A} | \bar{B} | \bar{A}+\bar{B} |
| 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 |
| 0 | 1 | 1 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 |

#### 제 2법칙 (2's Theorem)
- \bar{A+B} = \bar{A} \cdot \bar{B}
- 변수의 합에 대한 보수는 각 변수들의 보수의 곱과 같다.
- NOR 게이트 (\bar{A+B}) = negative-AND 게이트 (\bar{A}\bar{B})
| Input | Output | Output |
|:---:|:---:|:---:|
| A | B | \bar{A+B} | \bar{A} | \bar{B} | \bar{A}\cdot\bar{B} |
| 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 | 0 |
| 1 | 1 | 0 | 0 | 0 | 0 |

### NAND와 NOR의 만능특성
NAND 게이트만(\bar{AB})을 사용해서 각종 게이트들을 쉽게 만들 수 있다. 

## Reference
- [KOCW 강의 - 디지털 논리 회로 익히기](http://www.kocw.net/home/search/kemView.do?kemId=1319470)
- [Wikipedia - floating point arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)
- [Wikipedia - Logic Gate](https://en.wikipedia.org/wiki/Logic_gate)


