- [Introduction](#introduction)
  - [1. 리뷰](#1-리뷰)
  - [2. 공정기술의 척도](#2-공정기술의-척도)
  - [3. 트랜지스터 집적](#3-트랜지스터-집적)
  - [4. CPU칩의 전력소모](#4-cpu칩의-전력소모)
  - [5. 클럭](#5-클럭)
  - [6. IPC](#6-ipc)
  - [6. 무어의 법칙과 CPU의 성장](#6-무어의-법칙과-cpu의-성장)
  - [7. CISC vs RISC](#7-cisc-vs-risc)
  - [6. PGA](#6-pga)
  - [7. 성능](#7-성능)
  - [9. micro-architecture](#9-micro-architecture)
  - [8. Intel i7 processor](#8-intel-i7-processor)
  - [9. 웨이퍼(wafer)](#9-웨이퍼wafer)
  - [processor performance equation](#processor-performance-equation)
  - [11. SPEC](#11-spec)
- [Instruction Set Architecture](#instruction-set-architecture)
  - [1. 기계어](#1-기계어)
  - [2. 프로그래밍 언어](#2-프로그래밍-언어)

## Introduction

### 1. 리뷰
- 팬티엄4는 인텔 x86 아키텍처의 5번째 마이크로 아키텍처이다. (5세대)
- 1세대는 80386 : 파이프라인 x
- 2세대는 80486 : 최초의 파이프라인 x86 아키텍처 프로세서
- 3세대는 팬티엄 : 2개의 명령식 병렬로 처리하는 슈퍼스칼라
- 4세대는 팬티엄 프로, 팬티엄2, 팬티엄3 : 3개의 명령을 슈퍼스칼라, out-of-order execution (즉, 명령어를 순서대로 실행하는 것이아니고 앞에 명령이 막혀있으면 뒤에 명령이 먼저 실행), 
- 5세대는 팬티엄4 : 팬티엄 프로와 마찬가지로 3-way superscalar인데 파이프라인 단계 수가 팬티엄 프로의 10단계에서 20단계의 3-issue OOO 파이프라인으로 설계, 팬티엄프로에 비해 같은공정일때 클럭속도가 40% 향상, 그 이유는 한 명령어 처리과정을 20단계로 나누니까 한 단계에서 처리해야할 일이 줄어둠.   이론상으로 파이프라인 10->20단계로 되면 파이프라인의 클럭속도가 2배가 되어야하지만, 단계를 균등하게 쪼개기도 어렵고, 중간에 오버헤드도 많기 때문에 실제로는 40%정도의 클럭속도를 향상시킬 수 있다. (같은 공정일때)

### 2. 공정기술의 척도
- 공정기술의 척도는 minimum featured size인데, 우리가 실제로 프로세서에 사용되는 NAND 게이트들은 실제 물리적 설계를 보면 메탈, 폴리실리콘, 디퓨전과 같은 것들이 2차원형태로 이루어지고 이것들이 또 층을 이루어서 3차원으로 적층구조로 되어있다.
- 따라서, 공정기술의 척도는 이 선폭을 얼마나 얇게 하느냐 이다. 이 선폭의 기준 단위가 람다이다. 이 람다를 minimum featured size라고 한다.
  
### 3. 트랜지스터 집적
- 펜티엄4 마이크로프로세서의 경우 직접한 트랜지스터의 수는 5500만개이다.
- 컴퓨터는 결국 Programmable Digital System으로 모든 것이 AND, OR,  NOT과 같은 논리연산으로 구현된다. 이 AND, OR, NOT, 등의 논리회로는 NAND게이트 하나로 다 구현할 수 있다. 이 AND, OR, NOT 등의 논리게이트를 따로 만들지 않고 NAND게이트 하나만 쓰는 이유는 NAND게이트가 만들기가 더 쉽고 더 작기 때문이다. NAND 게이트를 AND게이트와 NOT게이트로 만들 수도 있지만, CMOS 2-input NAND게이트는 4개의 트랜지스터(n-mos, p-mos)로 훨씬 간단하게 만들 수 있다.
- 결국 컴퓨터 프로세서는 NAND게이트들과 게이트 간의 입/출력을 연결해주는 wire 들로 구성되어있다. 팬티엄4 마이크로프로세서는 트랜지스터의 수가 5500만개이고, 이것들이 2인풋 NAND게이트라고 가정하면 결국 팬티엄4는 약 1400만개의 2인풋 NAND게이트들로 구성된 칩이다.
- CPU(마이크로프로세서, 여기서는 단일 코어 프로세서)안에 있는 모든 메모리들 (즉, 캐시나 레지스터와 같은 상태 메모리들) 또한 전부 NAND게이트로 구성된다. 메모리들은 래치 형태로 만들어지는데 이 래치가 2인풋 NAND게이트 2개로 만들어진다. 결국 코어안에 있는 캐시, 레지스터와 같은 것들도 결국 낸드게이트들의 콜렉션이다.
  
### 4. CPU칩의 전력소모
- 전력소모 또한 굉장히 중요하다. 아무리 고성능 CPU 칩이라도 전력소모가 150W를 넘지 않는데, 150와트를 넘어가면 발열문제때문에 칩이 굉장히 뜨거워져서 에어쿨링 방식으로는 발열을 제어할 수 없다. 따라서 수냉식 쿨링을 해야하는데, 이러면 시스템 가격이 너무 비싸지기 때문에 아무리 고성능 CPU라도 최대 약 100W 정도으 전력을 소모한다.

### 5. 클럭
- 팬티엄4 프로세서는 약 3.2GHz이다. 
- 20stage 파이프라인은 명령어를 총 20단계로 나눈것인데, 이 하나의 stage를 1 clock cycle에 처리한다. 팬티엄4 프로세서의 클럭 주기가 3.2GHz이므로 1클럭 사이클은 약 3.2ns가 된다. 즉, 파이프라인의 한 스테이지를 3.2ns에 처리하는것이 된다.

### 6. IPC
- 컴퓨터의 성능을 평가하는 두가지 지표가 클럭속도와 IPC이다.
- 이 IPC는 클락당 몇개의 명령어를 처리하냐는 것이다. 같은 클럭에서 더 많은 명령어를 병렬로 처리하면 성능이 더 좋아지니까
- 팬티엄4의 IPC는 그 전 세대인 팬티엄 프로에 비해 약 10~20% 정도 떨어졌는데, 그 이유는 파이프라인의 단계가 더 많아졌기 때문이다. 이 파이프라인은 사실 미리 명령어를 예측해서 실행한다. 왜냐하면, 기계어도 마찬가지고 C, Python과 같은 고급언어도 마찬가지인데, 명령어의 순서를 바꾸는 명령들(기계어의 JUMP, 고급언어들의 If, else)은 현재 진행중이던 명령에서 순서를 바꿔 다른 명령어를 실행한다. 이게 만약, 파이프라인 설계라면 이러한 브랜치 명령들을 만나면, 명령어의 순서를 바꾸고 그 바뀐 명령어를 실행한 다음에야 파이프라인에서 다음 명령어를 fetch하는데 이러면 너무 느리다. (도중에 파이프라인이 멈추기떄문에) 따라서, 실제로는 프로세서가 미리 브랜치가 언제, 어디로 발생할지 다 예측해서 실행하는데 이것을 speculative execution이라 한다. 즉, 실제로는 명령어들을 하나씩 실행해야하지만, 이러면 너무 느리니까 병렬로, 미리 브랜치에 경우의 수에 있는 명령들을 가지고 와서 실행하게된다. 만약, 이 예측이 틀리면, 명령들을 전부 지우고 잘못된 곳부터 다시 fetch해야한다.
- 따라서, 파이프라인의 단계가 많아지면 적을때보다 취소되는 명령들이 많아지게되는데, 이것 때문에 팬티엄4의 IPC가 더 떨어진것이다.
- 파이프라인은 주로 폭과 깊이가 있는데, 깊이(뎁스)는 소위말해서 파이프라인의 단계수 이다. 폭은 3-issue 파이프라인 할때 이 issue를 말한다. 이것이 크면 더 넓은 것이다. 넓고 깊은 파이프라인일수록 성능이 증가하는데 그만큼 오버헤드 또한 증가한다. 깊이는 클럭 스피드와 관련이 있고, 폭은 IPC와 관계가 있다.
- 즉 3-issue라는 것은 한 사이클 당 3개의 명령어를 처리한다는 것이다. 3-issue라고도 하고 3-way 슈퍼스칼라 라고도 한다.
- Out-of-Order는 앞의 명령어가 막혀있으면 뒤에 명령어를 먼저 실행하는 것인데 이렇게 하면, 명령어의 대기장소가 필요하게 되는데 이러면 오버헤드는 10%정도 증가하는데 성능은 30%정도 높아진다.
- hyperthreading은 팬티엄4에 최초로 들어간 멀티스레딩 기술인데, CPU코어 하나가 초당 수백억개의 명령을 처리하니까, 병렬로 여러 작업을 하는것이아니고 하나씩 돌아가면서 한다. 즉, 1ms는 파워포인트하다가 1ms는 웹브라우저하다가 이런식으로 여러작업을 하나씩 실행하므로 사용자는 동시에 실행되는것처럼 보인다. (time sharing) 즉, 실제로 보면 한 순간에 한 클럭에는 하나의 프로그램만 실행하고 있는것이다. 그니까, 1ms는 파워포인트에 가서 파워포인트에 해당하는 명령어를 3개(3-issue 슈퍼스칼라)를 가져와서 CPU가 3개의 명령어를 한꺼번에 실행한다. 하지만, 이렇게 슈퍼스칼라가 적용된 프로세서가 한 프로그램에서만 명령어를 가져오면, 예를들어 4way 슈퍼스칼라인데 한 프로그램에서만 명령어를 가져오면 어떤 데이터는 프로그램에서 필요로 하는 데이터가 정수이고 어떤거는 소수이고 등등 이런것 때문에 4개를 다 안 쓰고, 2개나 3개만 써서 자원을 효율적으로 활용하기위해 나온 기술이 멀티스레딩이다. 즉 하이퍼스레딩을 통해 한 프로그램의 성능은 저하되지만, 전체적인 throughput(처리량)은 훨씬 높아져 체감성능은 훨씬 증가되는 것이다. 하지만, 2000년대 초반부터는 PC에서한 번에 2개의 프로그램을 동시에 실행하는 하이퍼스레딩, 일반적으로 멀티스레딩 기술이 적용되었다. 즉, 한 코어 안에서 PC를 2개를 두어서 2개의 프로그램에서 명령어를 가져와 실행하는 것이다. 예를들어 팬티엄4의 경우 3-issue 슈퍼스칼라이고, 하이퍼스레딩이 적용되었으므로, 하나는 파워포인트에서 명령어를 가져오고, 다른 하나는 인터넷익스플로어에서 가져오고, 다른 하나는 포토샵에서 명령어를 가져오고 이런 방식으로 명령어를 처리하는데 이것을 하이퍼스레딩이라고 한다. 즉, 슈퍼스칼라는 한 클럭 사이클에 여러개의 명령어를 실행하는 것이고, 하이퍼스레딩은 완전히 다른 독립적인 2개의 프로그램에서 명령어를 가져오는 것을 말한다. 즉 우리가 지금 쓰는 I7 칩도 한 클럭 사이클에 서로 다른 독립적인 2개의 프로그램을 동시에 작업한다.
- 캐시는 프로세서 안에 있는 메모리인데 (코어말고 프로세서 안에 코어안에 있는 메모리는 레지스터), 컴퓨터시스템에 있는 메모리는 전부 RAM인데, (하드디스크나 이런거는 I/O장치) 이 RAM은 SRAM과 DRAM 2개로 나뉜다. DRAM은 메인 메모리만 DRAM이고, CPU안에 있는 메모리(캐시,레지스터)는 모두 SRAM이다. 왜냐하면, 이 메모리들은 모두 NAND 게이트로 이루어져있기 때문이다. 이 캐시는 CPU는 메모리로 부터 데이터, 주소 등을 Fetch해서 레지스터에 담아서 명령들을 실행한다. CPU가 하는일은, PC가 가리키는 메모리 주소에 가서 해당하는 명령을 프로세서 안으로 fetch해서 프로세서안의 명령어 레지스터에 LOAD한다. 이 후 이 명령을 Decoding해서 명령을 해석한다. 그 다음 명령에 필요한 오퍼랜드를 기억장치로 부터 다시 인출해서 메모리 레지스터에 저장한다. 그 후 지정된 연산을 수행한 후 결과를 machine state를 업데이트한다. cpu는 이것을 계속 반복하는 것이다.
- 캐시는 cpu가 램에서 명령어나 데이터들을 가져오는데 한번 가져올때 캐시를 사용하면, 한번에 여러개의 명령어를 가져오고 캐시 메모리 안에 저장해뒀다가 다음에 또 다른 명령어를 실행할때 이미 캐시 안에 있는 명령어나 데이터면 이것을 재활용한다. CPU칩에서 명령어나 데이터를 캐시에서 발견할 확률이 99%이다.
- 처음에는 메모리와 CPU 사이의 거리가 비슷했는데 시간이 지날수록 점점 거리가 멀어져서 중간에 캐시 메모리를 둔 것이다. CPU가 메모리로 접근할려면 먼저, CPU안에서 캐시메모리에서 한번 뒤져보고 여기 없으면, 시스템 버스를 통해서 메모리 컨트롤러로 가서 메모리 컨트롤러에서 메모리 주소로 바꿔준다음에 메모리에 접근한다. 메모리보다 더 뒤에있는 I/O에 갈려면 버스나 이런것들이 CPU클락에 비해 훨씬 느리기 때문에 한참 기다려야한다. 요즘 프로세서들 기준으로 CPU가 메모리에서 데이터나 명령어들을 한번 가져오려면 보통 200~400 사이클 정도가 걸린다.
- 시스템버스는, CPU가 메모리에 갈려면 CPU칩에서 바깥으로 나와야되는데, 이 버스를 시스템 버스라고 한다. 이 시스템버스의 데이터 폭이 64bit 버스이다. 즉, 데이터가 한번에 8바이트씩 전송된다. 근데, 800MHz 시스템 버스인데, 8byte씩 전송하면 800MHz이므로 초당 800*10^6번의 쿨럭신호가 발생하고 이때마다 8바이트씩 전송되니까 결국에는 시스템버스에서 최대 데이터를 실어나를수 있는 용량이 초당 6.4GB/s인데, 이 용량을 Bandwidth라고한다. 이 bandwidth는 일정시간동안 얼마나 많은 일을 하느냐이다. CPu가 아무리 고성능이라해도 이 메모리로 가는 시스템 버스의 bandwidth가 작으면, CPU가 아무리 빨라도 메모리는 항상 기다리고 있어야한다. 즉, CPU 성능을 올릴려면 시스템버스의 Bandwidth도 같이 올라가야한다.
- 하지만, CPU가 워낙 해마다 빨라지고 시스템 버스는 그 속도를 따라가지 못하게 되어서 최근에는 버스구조가 전부 없어지고 Point-to-Point로 되어있다. point-to-potin는 한번에 한 와이어에 하나만 드라이브 하는 것이다. 즉, 드라이브 할 것이 하나뿐이므로 속도가 빨라진다.

### 6. 무어의 법칙과 CPU의 성장
- IC칩에 집적할 수 있는 트랜지스터의 수가 18개월마다 2배, 3년마다 4배씩 늘어남
- 골든 무어의 경험적인 이론
- 80년대 중반 이전까지는 CPU가 매년 25%씩 성장하다가, 80년대 중반부터 2002년때 매년 50%씩 고속성장을 했는데, 이 수치는 거의 무어의 법칙을 따라간 수치, 고속성장의 이유에는 RISC 아키텍처가 도입되었기 때문
- RISC 아키텍처는 명령어 셋을 간단하게 디자인함으로서 CPU설계를 간단하게 할 수 있고,결국 CPU 성능이 증가됨
- 하지만 2000년대 초반에 ILP(instruction level parrelism) 명령어 수준의 병렬성이 한계에 도달하였다. 왜냐하면, CPU들이 슈퍼스칼라 구조로 여려개의 명령어를 한 클럭사이클에 처리하는데 이것을 ?-issue superscalar라고 하고 파이프라인의 넓이라고 한다. 하지만, 이 처리할 수 있는 명령어의 수 (issue)가 즉, issue를 한번에 여러개를 처리하는 명령어의 수가 늘어날수록 실제 성능향상 폭은 이론적인 수치에 미치지못한다. 1~4개 정도 까지는 개수가 늘어날수록 성능향상폭이 큰데, 더 issue를 늘릴수록 실제로는 오버헤드와 파이프라인 각 단계가 굉장히 복잡해지기 때문에 issue를 늘릴수록 성능은 기대만큼 향상 안 하지만 하드웨어 복잡성은 대폭 증가하게 된다. 즉, 하드웨어 복잡성은 IW(issue-width)의 제곱에 비례하고, (이상적인 경우는 iw) 속도향상폭은 iw의 루트에도 못 미치게 비례한다. 즉, 복잡하게 issue-width를 넓게 해봤자, 성능은 조금 증가하고 하드웨어 복잡성은 어마어마하게 커진다.(열도많이나고, 전력소모도 많고, 크기도 커지고 등등)
- 이러한 문제로 2000년대 초반부터는 ILP(instruction level parrelism: 사이클당 처리되는 명령어의 수)를 증가시키기보다는 TLP(thread level parrelism)를 증가시키는 방향으로 바뀌었다. 여기서 스레드는 프로세서에서의 스레드인데, 프로세서에서 말하는 스레드는 Task, 즉 독립적인 프로그램을 말한다.
- 즉, 칩안에 하나의 코어를 복잡하게 설계해봤자, 성능은 별로증가안하고 크기와 발열은 엄청 증가한다. 따라서, 코어를 여러개 두는 것으로 방향을 바꿨다. 코어를 여러개 두고 이 코어들이 각각 다른 태스크를 하면 되니까 전체적인 throughput이 증가한다. 이것이 첫번쨰고 두번쨰는 멀티스레딩, 즉 한 코어안에서 두 개의 프로그램을 동시에 실행해서 성능(처리량)을 더 향상시킬 수 있다.
- 이러한 방향으로 바뀌면서 단일 코어의 성능은 매년 20% 향상로 줄어들었지만 멀티코어,멀티스레딩 즉 TLP를 높이는 방향으로 바뀌면서 체감성능(throughput)은 아직도 엄청 증가하고있다.

### 7. CISC vs RISC
- ISA는 설계방법에 따라 CISC와 RISC로 나눌수 있다.
- CISC(complex instruction set computer)
  - 명령어 형식이 많음
  - 명령어의 크기가 각각 다름
  - complex operation
  - 따라서, 프로세서 설계가 어렵고 그로인해 컴퓨터 시스템이 느려짐
  - x86 인텔
- RISC(redeuced instruction set computer)
  - CISC의 문제를 해결하기 위해 새로운 instruction set design인 RISC가 나옴
  - 명령어 형식이 적음
  - 명령어의 크기가 모두 같음
  - simple operation
  - Load-Stroe architectures
  - 따라서, 컴퓨터 설계가 쉬워지고 그로인해 속도도 빨라짐
  - RISC가 본격적으로 도입되는 1996년부터 컴퓨터의 성능이 거의 무어의 법칙을 따라감
  - ARM
  - -> 2002년부터 전력소모문제때문에 점차 성능향상 폭이 줄어듦(2002년 인텔 Pentium4 3.0GHz가 130W를 소비 -> 130W가 에어쿨링으로 제어할 수 있는 발열 마지노선, 많은 전력을 소비하므로 발열 발생)
  - -> CPU내부에 코어를 여러개 두면서 단일 CPU의 성능향상은 줄어들었지만 체감 성능은 훨씬 향상됨

### 6. PGA
- 핀그리드어레이는 CPU 칩 아래에 IO신호를 위한 핀들이 있다. 이 핀들을 마더보드에 꼽고 이 핀을 통해 데이터 입출력, 주소 신호, 전력공급(vdd)을 위한 신호들이 왔다갔다하는데, 이 핀을 478개를 사용한다는 것이다.

### 7. 성능
- CPU의 성능은 CPU 제조사(인텔, 암드, ibm, ..) 등이 아닌 제 3자로 구성된 집단에서 정한 기준에 따라 측정된다. 이것을 벤치마크라고 하는데 이 벤치마크는 cpu의 성능이 매번 바뀌기 때문에 벤치마크 기준또한 시간에 따라 바뀐다. 또 어떤 레퍼런스 머신을 통해서 상대적인 성능을 측정한다. 또한, pc용, 서버용 벤치마크가 다른데 pc용은 인티저 벤치마크, 서버용은 플로팅포인트 벤치마크를 사용한다. 서버용 애플리케이션들은 실수연산이 많기 때문이다.

### 9. micro-architecture
- 같은 기계어를 사용하는 프로세서라도 그들의 내부 디자인은 다르다.
- 마이크로아키텍처는 내부디자인, 구현을 말한다. (cache, pipelining, ...)
- so, micro-architecture means processor internal design or implementation
- 인텔 x86 프로세서의 마이크로아키텍쳐는 80386(1st.Gen), 80486(2nd.Gen), Pentium(3rd.Gen), Pentium Pro(4th.Gen), Pentium 4(5th.Gen) 등이 있다. 모두 같은 기계어인 x86을 사용하지만 내부회로는 모두 다르다.

### 8. Intel i7 processor
- 32nm : 미세선폭의 최소 단위가 32nm
- 1.17B trasistor
- 전력소모는 130W
- 3.46GHz 클럭 스피드
- ISA : x86-64, 팬티엄4는 x86 아키텍처, 즉 32비트 프로세서였는데요즘 인텔꺼는 x86-64아키텍처이다. x86(IA32)과 명령어는 모두 같은데, 데이터의 크기는 모두 64비트로 확장되었다. 이 데이터의 크기가 word이다. word는 cpu의 기본 데이터연산의 단위를 말한다.(default size for computation)
- 코어6개, 각 코어에는 4-issue 14-stage OOO pipeline. 그러니까, 코어가 6개이고 이것이 멀티스레딩 하니까 총 12개의 프로그램을 동시에 실행하는데, 각 코어마다 4-issue, 14-stage OOO 파이프라인이니까, 한 코어에서 프로그램당 최대 4개의 명령어를 순서와 관계없이 실행 할 수 있다.
- 2006년대 인텔은 팬티엄4같이 파이프라인 스테이지가 많으면, 클럭 속도는 올릴 수 있지만, 발열문제때문에 바람직하지 못하다는것을 알았고, 그래서 P6(팬티엄프로)를 기준으로 새로운 마이크로아키텍처를 만들었다. 4이슈, 14스테이지 oOO 파이프라인으로 되어있고 멀티코어와 파워소모를 줄이는데 초점을 맞춘 새로운 아키텍처이다. 2006년에 1세대이고 현재는 9세대 마이크로아키텍처이다. 1세대~9세대 전부 마이크로아키텍처이다. (내부 설계를 조금조금씩 바꾸면서 세대가 바뀐거다)
- 메모리컨트롤러, 팬티엄4시절에는 cpu가 메모리에 갈려면 cpu내부로 나와서 시스템버스를 타고 북쪽에 있는 노스브릿지 칩셉(메모리컨트롤러가 칩셋안에있음)을 가서 (칩셋의 역할이 칩과 칩을 연결해주는것) 거기서 메모리컨트롤러한테 메모리주소를 얻어서 메모리를 갔다. 이렇게하니까 너무 멀고 느리다. 이 i7 프로세서(요즘프로세서)는 cpu가 cpu밖에까지 나가서 칩셋으로 가지않아도 cpu가 직접 메모리카드를 컨트롤할수있다. 왜냐하면 요즘에는 메모리컨트롤러가 cpu칩 안으로 들어왓기떄문에. 또한, 메모리카드 채널이 3개가 있어서 하나의 cpu칩에서 매모리카드 3개를 동시에 제어할 수 있다. (여기서 메모리컨트롤러가 cpu안으로 들어온거지 메모리가 들어온거로 착각하면 안된다.) 메모리컨트롤러는 메모리를 제어하는 로직회로이다. cpu가 주소를 보내면 이 주소를 메모리컨트롤러가 메모리주소로 바꿔서 메모리를 제어한다. 과거에는 메모리컨트롤러가 cpu바깥이 칩셋안에있었는데, 요즘에는 이 메모리컨트롤러가 cpu안으로들어왔다. 따라서, 굳이 cpu가 메모리에 접근하기 위해 칩셋까지 갈 필요가 없다
- 즉, cpu에서 메모리로 가는 벗
- 메모리 : cpu안에는 주소류가 2가지가상메모리와 물리적메모리가 있다. 가상메모리는 프로그램의 주소이다. 메모리는 프로그램이 저장되어있는 영역이다. 여기서 명령어나 데이터가 모두 프로그램의 주소이다. 물리적메모리는 DRAM의 주소이다. 서로 다르다. I7에서 36비트 physical address라는것은 이 36비트로 디램을 어드레싱하는것이다. 디램도 바이트 배열이니까, 1바이트 하나마다 주소를 하나씩 갖으니까 이 프로세서는 2^36개의 메모리의 주소를 지정할 수 있고, 1개 주소마다 1바이트씩 가지니까 2^36바이트 즉, 64Gb까지 cpu가 어드레싱할수있다. 즉 이 cpu가 어드레싱 할 수 있는 디램의 최대용량은 64gb이다.
- 프로세서에서 말하는 스레드는 즉, 한 클럭 사이클에 작업할 수 있는 서로다른 프로그램(태스크)의 수
- 인텔 프로세서는 설계가 복잡해서 공정이 복잡하다. 메모리는 셀들이 바둑판처럼 깔려있어서 공정이 간단하다. 인텔은 지원해야할 칩셋이나 애플리케이션 장치들이 많아서 cpu장치가 복잡하다. 그래서 인텔 cpu은 항상 다른 프로세서보다 10~20%정도 오버헤드가 더 크다.

### 9. 웨이퍼(wafer)
- 이 웨이퍼는 크리스탈 실리콘이다. 이 웨이퍼에다가 공정을 해서 파고, 도핑하고, 빛으로 쬐소 패터닝 등을 하는데 이것을 공정이라고 한다. cpu가 아까 그 폴리곤들의 막대형태로 설계가 되면 그 형태대로 공정을 해서 웨이퍼에다가 만들어 논다. 그러면 웨이퍼에 있는 내모난 조각 하나하나가 다 cpu칩이다. 12인치(30센치) 웨이퍼 한장에 결함이 하나도 없을떄, cpu칩이 대략 280개 정도 만들수있다. 인텔은 yield가 상당히 높다 95~96%, ibm같은 서버용 회사들은 yield가 인텔보다 떨어진다.

### processor performance equation
- 컴퓨터의 성능을 수식으로 표현한 가장 중요한 식
- 컴퓨터의 성능은 어떤 프로그램을 실행했을때 실행시간이 결국 이 프로그램의 성능이다.
- 프로그램 실행시간을 구하는 식은 : T(프로그램실행시간) = NI * CPI * T
- NI는 한 프로그램에 있는 총 실행되어야할 명령어의 수이다.만약, 이 안에 명령어 수는 별로 안되는데 루프가 1000만번이라면, 실제 실행해야할 명령어의 수는 이 루프문 까지 포함하는 것이다. 즉 총 실행되어야할 명려엉의 수
- CPI는 명령어당 몇 사이클이 필요한가. 즉 IPC의 역이다. 한 명령어 처리하는데 몇 클락사이클이 걸리냐이다.
- T는 한 클락사이클의 시간이다.
- 다 곱해보면 단위가 s(초)만 나온다.
- 그러면, 컴퓨터의 성능을 높이려면 실행시간이 짧은게 좋다. 그러면 프로그램의 크기는 작아야하고 CPI는 작은게 좋고, IPC는 큰게좋다.
- T는 작은게좋다. T는 클락사이클 타임이고, 이것의 역이 클락스피드, 클락 주파수이다.
- 즉, 컴퓨터의 성능은 클럭스피드는 빠를수록, IPC는 클수록, 프로그램은 작을수록 좋다.
- 그러면 만약, 1GHz x86(CISC), 1GHz ARM(RISC) IPC도 모두 같을떄, 둘 중 누가 더 빠를까? RISC가 더 모던아키텍처이고 요즘 ISA가 모두 RISC구조로 되어있어서 RISC가 더 빠를껏 같지만, 그렇지않다. 왜냐하면, 두 CPU가 모두 IPC,클럭스피드가 같으면 프로그램 크기를 봐야하는데, 프로그램 크기는 CISC가 더 작다. 왜냐하면 CISC는 명령어의 수가 다양하고 종류도 많기 때문에 RISC가 3개의 명령어로 할 작업을 CISC는 1개로 처리가능하다. 즉, 프로그램 크기는 RISC로 하면 4~50%정도 더 커진다. 즉, 같은 클럭스피드, 같은 IPC이면 CISC가 더 빠르다. 왜냐하면 CISC가 명령어의 종류도 많고 다양하니까 프로그램의 크기는 작아져 실행해야할 명령어의 수는 작아지기떄문이다.
- 팬티엄과 팬티엄프로 비교 : 둘다 x86이므로 프로그램 크기는 같다. 클럭스피드는 팬티엄프로가 2배 빠르다. 하지만, 팬티엄프로는 팬티엄 보다 2way에서 3way이고, OOO이므로 IPC가 더 커졌기때문에 실제 성능향상은 클록속도의 2배보다 2배 이상으로 성능이 증가했다.
- 팬티엄프로(2세대)와 팬티엄4(5세대) : 클럭속도는 14배빨라졌지만, 성능은 10배정도 향상. 즉 IPC는 떨어짐, 왜냐하면 팬티엄프로 제너레이션에서 팬티엄4로 가면서 클럭속도는 40%정도 좋아지고 IPC는 떨어졌다. 왜냐하면 파이프라인이 단계가 더 많아서 더 깊어져서 CPu가 예측한 분기들이 취소될때 더 많이 취소되기떄문에 IPC는 떨어졌다.

### 11. SPEC
- spec은 standard performance evaluation cororation으로서, 컴퓨터 성능을 객관적으로 비교하기위한 제 3자의 비영리 단체이다. cpu 제조사들이 서로 모여서 비영리 단체를 만들고, 이 단체로 하여금 서로 공정하게 평가하도록 만든것이다. 
- cpu성능을 평가하기위한 벤치마킹을 speccpu라고하고 이거 말고도 그래픽 벤치마킹, 웹 벤치마킹 등이 다 따로있다.
- 예를들어 spec cpu2006은 두 개의 밴치마크가 있는데 하나는 pc용을 위한 c인티저2006, 서버용은 플로팅포인트2006이 있으며, 피시용 벤치마크에는 12개의 애플리케이션, 서버용은 18개의 애플리케이션으로 평가한다.
- 스펙80,85,...,06으로 오면서도 한번도 안바뀐 어플리케이션은 GCC이다.(gnu c compiler)
- 이제 SPEC단체에서 래퍼런스 머신을 하나 정해놓고 위의 애플리케이션을 모두 돌려서 초 단위로 기록한다. 그 후 테스트 CPU를 이 레퍼런스 머신과 비교해서 애플리케이션마다 몇배더 빠르냐로 SPEC RATIo를 구하고 그 다음에 이 Rati를 기하평균낸다.

## Instruction Set Architecture

### 1. 기계어
- 기계어도 프로그래밍 언어 중 하나이다. 하지만, 0과1로 프로그래밍 하기 어려우니까 사람이 사용하는 언어와 유사한 high-level 프로그래밍 언어를 개발해 놓고 이 컴파일러라는 traslator를 개발해서 c,java,python으로 개발을 하면 컴파일러나 인터프리터가 해당하는 machine의 ISA(기계어)로 번역해준다. 굳이 사람들이 0과1로 프로그래밍 할 필요없다.
- c언어는 컴파일러가 c언어를 기계어로 번역해준다. 이 과정을 컴파일이라고하는데, 이 기계어도 아키텍처마다 다르다는 것이다. 즉, x86, ARM 등 모두 사용하는 ISA가 다르다. 그렇기 때문에 컴파일러는 바로 기계어로 만들지는 않고 어셈블러를 통해 어셈블리어로 먼저 c언어를 번역한다. 대부분 컴파일이라고 하면 이 어셈블러 과정도 포함해서 말한다. JAVA는 컴파일러가 아니고, 인터프리터를 통해서 JAVA언어를 기계어로 번역하고, 실행한다. JVM은 자바버추얼머신으로서 자바의 인터프리터인데, 자바를 기계어로 번역하고, 이 JVM머신 위에서 직접 실행까지도 한다. 따라서 JVM만 있으면 어떤 컴퓨터에서든 이 자바를 실행할 수 있어서 호환성이 좋다.

### 2. 프로그래밍 언어
- 저레벨(기계어) 프로그래밍언어 : binary, IA32, IA64, ARM, MIPS, 
- 고수준(high-level)프로그래밍언어는 다음과 같이 분류할수잇다.
  - procedural(imperative) language : C, Pascal, FOTRAN
  - Objected-Oriented Language : C++, C#, JAVA, Kotlin
  - Functional(declarative) language : Lisp, Scheme
  - multiple paradigm language(hybird, 위의개념들이 모두 있는 언어): Python, 
- 위의 고수준 언어에서 최초의 고수준 프로그래밍 언어는 imerative 언어이다. 이것이 최초의 프로그래밍 언어이다. 원래 머신인스트럭션의 역할은 기계명령어를 하나 실행하면 기계스테이스가 바뀐다. 고수준 프로그래밍 언어는 intruction가 아니라 하나하나를 statement라고 한다. 즉, 문장, 하나의 statement(문장)을 실행하면 machine state가 바뀌는거다. 이런 언어를 imperative language라고 한다. 그러다가 어떤 작업을 여러번 할 수 있으니까, 이 작업을 procedure형태로 묶어서 이 procedure를 하면 해당하는 안에 있는 statement를 여러개 실행하고 그 결과만 받으면 되니까, 이런 procedure형태로 묶은 언어를 procedural language라고 한다. procedural 언어의 특징은 프로시져 안에 선언된 데이터 즉, 변수들도 프로시저 안에 스코프를 가지고잇다. 이 안에서만 이 데이터(변수)가 유효하다. 즉, imperative language의 발전된 형태가 procedural 언어이다. 시간이 지나고 이 둘다 과거의 것이고 비슷하니가 procedural 언어로 퉁친다. 이 프로시져언어의 대표적인 언어가 c언어이다. 이 c언어는 UNIX라는 OS를 개발하기 위해 만들어진언어다. 그전에 언어들은 너무 복잡하니까 쉽게 개발하기 위해 새로운언어를 개발한것이다.
- pascal, fotran 은 과학계산용 언어로 80년대 많이 제한된 교과서적인 언어이다.
- 여기서 더 발전해서 객체지향언어가 나왔는데, 프로시져언어는 프로시져형태로 코드를 묶어논것인데, 이렇게 하지말고 객체 형태로 묶어놓고 프로그램은 이 객체들 간의 인터렉션으로 본다는 것이다. 이 객체 안에는 데이터도 있고 함수도있다. 이러면 좀더 프로그램을 사용하기 쉽고 다른사람이 작성한 프로그램을 이용하기도 쉬워진다. 객체지향언어의 가장 기초가되는 언어가 자바이다. C++은 C를 객체지향형태로 한건데 실제로 내부적으로는 C++은 C와 같다.
- 이 procudural language나 oriented language는 모두 how를 descirbe하는데, 
