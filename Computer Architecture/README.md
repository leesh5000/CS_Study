- [Introduction](#introduction)
  - [1. 리뷰](#1-리뷰)
  - [2. 공정기술의 척도](#2-공정기술의-척도)
  - [3. 트랜지스터 집적](#3-트랜지스터-집적)
  - [4. CPU칩의 전력소모](#4-cpu칩의-전력소모)
  - [5. 클럭](#5-클럭)
  - [6. IPC](#6-ipc)
  - [6. 무어의 법칙과 CPU의 성장](#6-무어의-법칙과-cpu의-성장)
  - [7. CISC vs RISC](#7-cisc-vs-risc)
  - [6. PGA](#6-pga)
  - [7. 성능](#7-성능)
  - [9. micro-architecture](#9-micro-architecture)
  - [8. Intel i7 processor](#8-intel-i7-processor)
  - [9. 웨이퍼(wafer)](#9-웨이퍼wafer)
  - [processor performance equation](#processor-performance-equation)
  - [11. SPEC](#11-spec)
- [Instruction Set Architecture](#instruction-set-architecture)
  - [1. 기계어](#1-기계어)
  - [2. 프로그래밍 언어](#2-프로그래밍-언어)
  - [3. 컴파일러](#3-컴파일러)
  - [4. Machine State](#4-machine-state)
  - [5. Machine Instruction](#5-machine-instruction)
    - [instruction type](#instruction-type)
  - [MIPS Addressing Modes](#mips-addressing-modes)
  - [4. Procedure Call & Return](#4-procedure-call--return)
  - [5. Linking](#5-linking)

## Introduction

### 1. 리뷰
- 팬티엄4는 인텔 x86 아키텍처의 5번째 마이크로 아키텍처이다. (5세대)
- 1세대는 80386 : 파이프라인 x
- 2세대는 80486 : 최초의 파이프라인 x86 아키텍처 프로세서
- 3세대는 팬티엄 : 2개의 명령식 병렬로 처리하는 슈퍼스칼라
- 4세대는 팬티엄 프로, 팬티엄2, 팬티엄3 : 3개의 명령을 슈퍼스칼라, out-of-order execution (즉, 명령어를 순서대로 실행하는 것이아니고 앞에 명령이 막혀있으면 뒤에 명령이 먼저 실행), 
- 5세대는 팬티엄4 : 팬티엄 프로와 마찬가지로 3-way superscalar인데 파이프라인 단계 수가 팬티엄 프로의 10단계에서 20단계의 3-issue OOO 파이프라인으로 설계, 팬티엄프로에 비해 같은공정일때 클럭속도가 40% 향상, 그 이유는 한 명령어 처리과정을 20단계로 나누니까 한 단계에서 처리해야할 일이 줄어둠.   이론상으로 파이프라인 10->20단계로 되면 파이프라인의 클럭속도가 2배가 되어야하지만, 단계를 균등하게 쪼개기도 어렵고, 중간에 오버헤드도 많기 때문에 실제로는 40%정도의 클럭속도를 향상시킬 수 있다. (같은 공정일때)

### 2. 공정기술의 척도
- 공정기술의 척도는 minimum featured size인데, 우리가 실제로 프로세서에 사용되는 NAND 게이트들은 실제 물리적 설계를 보면 메탈, 폴리실리콘, 디퓨전과 같은 것들이 2차원형태로 이루어지고 이것들이 또 층을 이루어서 3차원으로 적층구조로 되어있다.
- 따라서, 공정기술의 척도는 이 선폭을 얼마나 얇게 하느냐 이다. 이 선폭의 기준 단위가 람다이다. 이 람다를 minimum featured size라고 한다.
  
### 3. 트랜지스터 집적
- 펜티엄4 마이크로프로세서의 경우 직접한 트랜지스터의 수는 5500만개이다.
- 컴퓨터는 결국 Programmable Digital System으로 모든 것이 AND, OR,  NOT과 같은 논리연산으로 구현된다. 이 AND, OR, NOT, 등의 논리회로는 NAND게이트 하나로 다 구현할 수 있다. 이 AND, OR, NOT 등의 논리게이트를 따로 만들지 않고 NAND게이트 하나만 쓰는 이유는 NAND게이트가 만들기가 더 쉽고 더 작기 때문이다. NAND 게이트를 AND게이트와 NOT게이트로 만들 수도 있지만, CMOS 2-input NAND게이트는 4개의 트랜지스터(n-mos, p-mos)로 훨씬 간단하게 만들 수 있다.
- 결국 컴퓨터 프로세서는 NAND게이트들과 게이트 간의 입/출력을 연결해주는 wire 들로 구성되어있다. 팬티엄4 마이크로프로세서는 트랜지스터의 수가 5500만개이고, 이것들이 2인풋 NAND게이트라고 가정하면 결국 팬티엄4는 약 1400만개의 2인풋 NAND게이트들로 구성된 칩이다.
- CPU(마이크로프로세서, 여기서는 단일 코어 프로세서)안에 있는 모든 메모리들 (즉, 캐시나 레지스터와 같은 상태 메모리들) 또한 전부 NAND게이트로 구성된다. 메모리들은 래치 형태로 만들어지는데 이 래치가 2인풋 NAND게이트 2개로 만들어진다. 결국 코어안에 있는 캐시, 레지스터와 같은 것들도 결국 낸드게이트들의 콜렉션이다.
  
### 4. CPU칩의 전력소모
- 전력소모 또한 굉장히 중요하다. 아무리 고성능 CPU 칩이라도 전력소모가 150W를 넘지 않는데, 150와트를 넘어가면 발열문제때문에 칩이 굉장히 뜨거워져서 에어쿨링 방식으로는 발열을 제어할 수 없다. 따라서 수냉식 쿨링을 해야하는데, 이러면 시스템 가격이 너무 비싸지기 때문에 아무리 고성능 CPU라도 최대 약 100W 정도으 전력을 소모한다.

### 5. 클럭
- 팬티엄4 프로세서는 약 3.2GHz이다. 
- 20stage 파이프라인은 명령어를 총 20단계로 나눈것인데, 이 하나의 stage를 1 clock cycle에 처리한다. 팬티엄4 프로세서의 클럭 주기가 3.2GHz이므로 1클럭 사이클은 약 3.2ns가 된다. 즉, 파이프라인의 한 스테이지를 3.2ns에 처리하는것이 된다.

### 6. IPC
- 컴퓨터의 성능을 평가하는 두가지 지표가 클럭속도와 IPC이다.
- 이 IPC는 클락당 몇개의 명령어를 처리하냐는 것이다. 같은 클럭에서 더 많은 명령어를 병렬로 처리하면 성능이 더 좋아지니까
- 팬티엄4의 IPC는 그 전 세대인 팬티엄 프로에 비해 약 10~20% 정도 떨어졌는데, 그 이유는 파이프라인의 단계가 더 많아졌기 때문이다. 이 파이프라인은 사실 미리 명령어를 예측해서 실행한다. 왜냐하면, 기계어도 마찬가지고 C, Python과 같은 고급언어도 마찬가지인데, 명령어의 순서를 바꾸는 명령들(기계어의 JUMP, 고급언어들의 If, else)은 현재 진행중이던 명령에서 순서를 바꿔 다른 명령어를 실행한다. 이게 만약, 파이프라인 설계라면 이러한 브랜치 명령들을 만나면, 명령어의 순서를 바꾸고 그 바뀐 명령어를 실행한 다음에야 파이프라인에서 다음 명령어를 fetch하는데 이러면 너무 느리다. (도중에 파이프라인이 멈추기떄문에) 따라서, 실제로는 프로세서가 미리 브랜치가 언제, 어디로 발생할지 다 예측해서 실행하는데 이것을 speculative execution이라 한다. 즉, 실제로는 명령어들을 하나씩 실행해야하지만, 이러면 너무 느리니까 병렬로, 미리 브랜치에 경우의 수에 있는 명령들을 가지고 와서 실행하게된다. 만약, 이 예측이 틀리면, 명령들을 전부 지우고 잘못된 곳부터 다시 fetch해야한다.
- 따라서, 파이프라인의 단계가 많아지면 적을때보다 취소되는 명령들이 많아지게되는데, 이것 때문에 팬티엄4의 IPC가 더 떨어진것이다.
- 파이프라인은 주로 폭과 깊이가 있는데, 깊이(뎁스)는 소위말해서 파이프라인의 단계수 이다. 폭은 3-issue 파이프라인 할때 이 issue를 말한다. 이것이 크면 더 넓은 것이다. 넓고 깊은 파이프라인일수록 성능이 증가하는데 그만큼 오버헤드 또한 증가한다. 깊이는 클럭 스피드와 관련이 있고, 폭은 IPC와 관계가 있다.
- 즉 3-issue라는 것은 한 사이클 당 3개의 명령어를 처리한다는 것이다. 3-issue라고도 하고 3-way 슈퍼스칼라 라고도 한다.
- Out-of-Order는 앞의 명령어가 막혀있으면 뒤에 명령어를 먼저 실행하는 것인데 이렇게 하면, 명령어의 대기장소가 필요하게 되는데 이러면 오버헤드는 10%정도 증가하는데 성능은 30%정도 높아진다.
- hyperthreading은 팬티엄4에 최초로 들어간 멀티스레딩 기술인데, CPU코어 하나가 초당 수백억개의 명령을 처리하니까, 병렬로 여러 작업을 하는것이아니고 하나씩 돌아가면서 한다. 즉, 1ms는 파워포인트하다가 1ms는 웹브라우저하다가 이런식으로 여러작업을 하나씩 실행하므로 사용자는 동시에 실행되는것처럼 보인다. (time sharing) 즉, 실제로 보면 한 순간에 한 클럭에는 하나의 프로그램만 실행하고 있는것이다. 그니까, 1ms는 파워포인트에 가서 파워포인트에 해당하는 명령어를 3개(3-issue 슈퍼스칼라)를 가져와서 CPU가 3개의 명령어를 한꺼번에 실행한다. 하지만, 이렇게 슈퍼스칼라가 적용된 프로세서가 한 프로그램에서만 명령어를 가져오면, 예를들어 4way 슈퍼스칼라인데 한 프로그램에서만 명령어를 가져오면 어떤 데이터는 프로그램에서 필요로 하는 데이터가 정수이고 어떤거는 소수이고 등등 이런것 때문에 4개를 다 안 쓰고, 2개나 3개만 써서 자원을 효율적으로 활용하기위해 나온 기술이 멀티스레딩이다. 즉 하이퍼스레딩을 통해 한 프로그램의 성능은 저하되지만, 전체적인 throughput(처리량)은 훨씬 높아져 체감성능은 훨씬 증가되는 것이다. 하지만, 2000년대 초반부터는 PC에서한 번에 2개의 프로그램을 동시에 실행하는 하이퍼스레딩, 일반적으로 멀티스레딩 기술이 적용되었다. 즉, 한 코어 안에서 PC를 2개를 두어서 2개의 프로그램에서 명령어를 가져와 실행하는 것이다. 예를들어 팬티엄4의 경우 3-issue 슈퍼스칼라이고, 하이퍼스레딩이 적용되었으므로, 하나는 파워포인트에서 명령어를 가져오고, 다른 하나는 인터넷익스플로어에서 가져오고, 다른 하나는 포토샵에서 명령어를 가져오고 이런 방식으로 명령어를 처리하는데 이것을 하이퍼스레딩이라고 한다. 즉, 슈퍼스칼라는 한 클럭 사이클에 여러개의 명령어를 실행하는 것이고, 하이퍼스레딩은 완전히 다른 독립적인 2개의 프로그램에서 명령어를 가져오는 것을 말한다. 즉 우리가 지금 쓰는 I7 칩도 한 클럭 사이클에 서로 다른 독립적인 2개의 프로그램을 동시에 작업한다.
- 캐시는 프로세서 안에 있는 메모리인데 (코어말고 프로세서 안에 코어안에 있는 메모리는 레지스터), 컴퓨터시스템에 있는 메모리는 전부 RAM인데, (하드디스크나 이런거는 I/O장치) 이 RAM은 SRAM과 DRAM 2개로 나뉜다. DRAM은 메인 메모리만 DRAM이고, CPU안에 있는 메모리(캐시,레지스터)는 모두 SRAM이다. 왜냐하면, 이 메모리들은 모두 NAND 게이트로 이루어져있기 때문이다. 이 캐시는 CPU는 메모리로 부터 데이터, 주소 등을 Fetch해서 레지스터에 담아서 명령들을 실행한다. CPU가 하는일은, PC가 가리키는 메모리 주소에 가서 해당하는 명령을 프로세서 안으로 fetch해서 프로세서안의 명령어 레지스터에 LOAD한다. 이 후 이 명령을 Decoding해서 명령을 해석한다. 그 다음 명령에 필요한 오퍼랜드를 기억장치로 부터 다시 인출해서 메모리 레지스터에 저장한다. 그 후 지정된 연산을 수행한 후 결과를 machine state를 업데이트한다. cpu는 이것을 계속 반복하는 것이다.
- 캐시는 cpu가 램에서 명령어나 데이터들을 가져오는데 한번 가져올때 캐시를 사용하면, 한번에 여러개의 명령어를 가져오고 캐시 메모리 안에 저장해뒀다가 다음에 또 다른 명령어를 실행할때 이미 캐시 안에 있는 명령어나 데이터면 이것을 재활용한다. CPU칩에서 명령어나 데이터를 캐시에서 발견할 확률이 99%이다.
- 처음에는 메모리와 CPU 사이의 거리가 비슷했는데 시간이 지날수록 점점 거리가 멀어져서 중간에 캐시 메모리를 둔 것이다. CPU가 메모리로 접근할려면 먼저, CPU안에서 캐시메모리에서 한번 뒤져보고 여기 없으면, 시스템 버스를 통해서 메모리 컨트롤러로 가서 메모리 컨트롤러에서 메모리 주소로 바꿔준다음에 메모리에 접근한다. 메모리보다 더 뒤에있는 I/O에 갈려면 버스나 이런것들이 CPU클락에 비해 훨씬 느리기 때문에 한참 기다려야한다. 요즘 프로세서들 기준으로 CPU가 메모리에서 데이터나 명령어들을 한번 가져오려면 보통 200~400 사이클 정도가 걸린다.
- 시스템버스는, CPU가 메모리에 갈려면 CPU칩에서 바깥으로 나와야되는데, 이 버스를 시스템 버스라고 한다. 이 시스템버스의 데이터 폭이 64bit 버스이다. 즉, 데이터가 한번에 8바이트씩 전송된다. 근데, 800MHz 시스템 버스인데, 8byte씩 전송하면 800MHz이므로 초당 800*10^6번의 쿨럭신호가 발생하고 이때마다 8바이트씩 전송되니까 결국에는 시스템버스에서 최대 데이터를 실어나를수 있는 용량이 초당 6.4GB/s인데, 이 용량을 Bandwidth라고한다. 이 bandwidth는 일정시간동안 얼마나 많은 일을 하느냐이다. CPu가 아무리 고성능이라해도 이 메모리로 가는 시스템 버스의 bandwidth가 작으면, CPU가 아무리 빨라도 메모리는 항상 기다리고 있어야한다. 즉, CPU 성능을 올릴려면 시스템버스의 Bandwidth도 같이 올라가야한다.
- 하지만, CPU가 워낙 해마다 빨라지고 시스템 버스는 그 속도를 따라가지 못하게 되어서 최근에는 버스구조가 전부 없어지고 Point-to-Point로 되어있다. point-to-potin는 한번에 한 와이어에 하나만 드라이브 하는 것이다. 즉, 드라이브 할 것이 하나뿐이므로 속도가 빨라진다.

### 6. 무어의 법칙과 CPU의 성장
- IC칩에 집적할 수 있는 트랜지스터의 수가 18개월마다 2배, 3년마다 4배씩 늘어남
- 골든 무어의 경험적인 이론
- 80년대 중반 이전까지는 CPU가 매년 25%씩 성장하다가, 80년대 중반부터 2002년때 매년 50%씩 고속성장을 했는데, 이 수치는 거의 무어의 법칙을 따라간 수치, 고속성장의 이유에는 RISC 아키텍처가 도입되었기 때문
- RISC 아키텍처는 명령어 셋을 간단하게 디자인함으로서 CPU설계를 간단하게 할 수 있고,결국 CPU 성능이 증가됨
- 하지만 2000년대 초반에 ILP(instruction level parrelism) 명령어 수준의 병렬성이 한계에 도달하였다. 왜냐하면, CPU들이 슈퍼스칼라 구조로 여려개의 명령어를 한 클럭사이클에 처리하는데 이것을 ?-issue superscalar라고 하고 파이프라인의 넓이라고 한다. 하지만, 이 처리할 수 있는 명령어의 수 (issue)가 즉, issue를 한번에 여러개를 처리하는 명령어의 수가 늘어날수록 실제 성능향상 폭은 이론적인 수치에 미치지못한다. 1~4개 정도 까지는 개수가 늘어날수록 성능향상폭이 큰데, 더 issue를 늘릴수록 실제로는 오버헤드와 파이프라인 각 단계가 굉장히 복잡해지기 때문에 issue를 늘릴수록 성능은 기대만큼 향상 안 하지만 하드웨어 복잡성은 대폭 증가하게 된다. 즉, 하드웨어 복잡성은 IW(issue-width)의 제곱에 비례하고, (이상적인 경우는 iw) 속도향상폭은 iw의 루트에도 못 미치게 비례한다. 즉, 복잡하게 issue-width를 넓게 해봤자, 성능은 조금 증가하고 하드웨어 복잡성은 어마어마하게 커진다.(열도많이나고, 전력소모도 많고, 크기도 커지고 등등)
- 이러한 문제로 2000년대 초반부터는 ILP(instruction level parrelism: 사이클당 처리되는 명령어의 수)를 증가시키기보다는 TLP(thread level parrelism)를 증가시키는 방향으로 바뀌었다. 여기서 스레드는 프로세서에서의 스레드인데, 프로세서에서 말하는 스레드는 Task, 즉 독립적인 프로그램을 말한다.
- 즉, 칩안에 하나의 코어를 복잡하게 설계해봤자, 성능은 별로증가안하고 크기와 발열은 엄청 증가한다. 따라서, 코어를 여러개 두는 것으로 방향을 바꿨다. 코어를 여러개 두고 이 코어들이 각각 다른 태스크를 하면 되니까 전체적인 throughput이 증가한다. 이것이 첫번쨰고 두번쨰는 멀티스레딩, 즉 한 코어안에서 두 개의 프로그램을 동시에 실행해서 성능(처리량)을 더 향상시킬 수 있다.
- 이러한 방향으로 바뀌면서 단일 코어의 성능은 매년 20% 향상로 줄어들었지만 멀티코어,멀티스레딩 즉 TLP를 높이는 방향으로 바뀌면서 체감성능(throughput)은 아직도 엄청 증가하고있다.

### 7. CISC vs RISC
- ISA는 설계방법에 따라 CISC와 RISC로 나눌수 있다.
- CISC(complex instruction set computer)
  - 명령어 형식이 많음
  - 명령어의 크기가 각각 다름
  - complex operation
  - 따라서, 프로세서 설계가 어렵고 그로인해 컴퓨터 시스템이 느려짐
  - x86 인텔
- RISC(redeuced instruction set computer)
  - CISC의 문제를 해결하기 위해 새로운 instruction set design인 RISC가 나옴
  - 명령어 형식이 적음
  - 명령어의 크기가 모두 같음
  - simple operation
  - Load-Stroe architectures
  - 따라서, 컴퓨터 설계가 쉬워지고 그로인해 속도도 빨라짐
  - RISC가 본격적으로 도입되는 1996년부터 컴퓨터의 성능이 거의 무어의 법칙을 따라감
  - ARM
  - -> 2002년부터 전력소모문제때문에 점차 성능향상 폭이 줄어듦(2002년 인텔 Pentium4 3.0GHz가 130W를 소비 -> 130W가 에어쿨링으로 제어할 수 있는 발열 마지노선, 많은 전력을 소비하므로 발열 발생)
  - -> CPU내부에 코어를 여러개 두면서 단일 CPU의 성능향상은 줄어들었지만 체감 성능은 훨씬 향상됨

### 6. PGA
- 핀그리드어레이는 CPU 칩 아래에 IO신호를 위한 핀들이 있다. 이 핀들을 마더보드에 꼽고 이 핀을 통해 데이터 입출력, 주소 신호, 전력공급(vdd)을 위한 신호들이 왔다갔다하는데, 이 핀을 478개를 사용한다는 것이다.

### 7. 성능
- CPU의 성능은 CPU 제조사(인텔, 암드, ibm, ..) 등이 아닌 제 3자로 구성된 집단에서 정한 기준에 따라 측정된다. 이것을 벤치마크라고 하는데 이 벤치마크는 cpu의 성능이 매번 바뀌기 때문에 벤치마크 기준또한 시간에 따라 바뀐다. 또 어떤 레퍼런스 머신을 통해서 상대적인 성능을 측정한다. 또한, pc용, 서버용 벤치마크가 다른데 pc용은 인티저 벤치마크, 서버용은 플로팅포인트 벤치마크를 사용한다. 서버용 애플리케이션들은 실수연산이 많기 때문이다.

### 9. micro-architecture
- 같은 기계어를 사용하는 프로세서라도 그들의 내부 디자인은 다르다.
- 마이크로아키텍처는 내부디자인, 구현을 말한다. (cache, pipelining, ...)
- so, micro-architecture means processor internal design or implementation
- 인텔 x86 프로세서의 마이크로아키텍쳐는 80386(1st.Gen), 80486(2nd.Gen), Pentium(3rd.Gen), Pentium Pro(4th.Gen), Pentium 4(5th.Gen) 등이 있다. 모두 같은 기계어인 x86을 사용하지만 내부회로는 모두 다르다.

### 8. Intel i7 processor
- 32nm : 미세선폭의 최소 단위가 32nm
- 1.17B trasistor
- 전력소모는 130W
- 3.46GHz 클럭 스피드
- ISA : x86-64, 팬티엄4는 x86 아키텍처, 즉 32비트 프로세서였는데요즘 인텔꺼는 x86-64아키텍처이다. x86(IA32)과 명령어는 모두 같은데, 데이터의 크기는 모두 64비트로 확장되었다. 이 데이터의 크기가 word이다. word는 cpu의 기본 데이터연산의 단위를 말한다.(default size for computation)
- 코어6개, 각 코어에는 4-issue 14-stage OOO pipeline. 그러니까, 코어가 6개이고 이것이 멀티스레딩 하니까 총 12개의 프로그램을 동시에 실행하는데, 각 코어마다 4-issue, 14-stage OOO 파이프라인이니까, 한 코어에서 프로그램당 최대 4개의 명령어를 순서와 관계없이 실행 할 수 있다.
- 2006년대 인텔은 팬티엄4같이 파이프라인 스테이지가 많으면, 클럭 속도는 올릴 수 있지만, 발열문제때문에 바람직하지 못하다는것을 알았고, 그래서 P6(팬티엄프로)를 기준으로 새로운 마이크로아키텍처를 만들었다. 4이슈, 14스테이지 oOO 파이프라인으로 되어있고 멀티코어와 파워소모를 줄이는데 초점을 맞춘 새로운 아키텍처이다. 2006년에 1세대이고 현재는 9세대 마이크로아키텍처이다. 1세대~9세대 전부 마이크로아키텍처이다. (내부 설계를 조금조금씩 바꾸면서 세대가 바뀐거다)
- 메모리컨트롤러, 팬티엄4시절에는 cpu가 메모리에 갈려면 cpu내부로 나와서 시스템버스를 타고 북쪽에 있는 노스브릿지 칩셉(메모리컨트롤러가 칩셋안에있음)을 가서 (칩셋의 역할이 칩과 칩을 연결해주는것) 거기서 메모리컨트롤러한테 메모리주소를 얻어서 메모리를 갔다. 이렇게하니까 너무 멀고 느리다. 이 i7 프로세서(요즘프로세서)는 cpu가 cpu밖에까지 나가서 칩셋으로 가지않아도 cpu가 직접 메모리카드를 컨트롤할수있다. 왜냐하면 요즘에는 메모리컨트롤러가 cpu칩 안으로 들어왓기떄문에. 또한, 메모리카드 채널이 3개가 있어서 하나의 cpu칩에서 매모리카드 3개를 동시에 제어할 수 있다. (여기서 메모리컨트롤러가 cpu안으로 들어온거지 메모리가 들어온거로 착각하면 안된다.) 메모리컨트롤러는 메모리를 제어하는 로직회로이다. cpu가 주소를 보내면 이 주소를 메모리컨트롤러가 메모리주소로 바꿔서 메모리를 제어한다. 과거에는 메모리컨트롤러가 cpu바깥이 칩셋안에있었는데, 요즘에는 이 메모리컨트롤러가 cpu안으로들어왔다. 따라서, 굳이 cpu가 메모리에 접근하기 위해 칩셋까지 갈 필요가 없다
- 즉, cpu에서 메모리로 가는 벗
- 메모리 : cpu안에는 주소류가 2가지가상메모리와 물리적메모리가 있다. 가상메모리는 프로그램의 주소이다. 메모리는 프로그램이 저장되어있는 영역이다. 여기서 명령어나 데이터가 모두 프로그램의 주소이다. 물리적메모리는 DRAM의 주소이다. 서로 다르다. I7에서 36비트 physical address라는것은 이 36비트로 디램을 어드레싱하는것이다. 디램도 바이트 배열이니까, 1바이트 하나마다 주소를 하나씩 갖으니까 이 프로세서는 2^36개의 메모리의 주소를 지정할 수 있고, 1개 주소마다 1바이트씩 가지니까 2^36바이트 즉, 64Gb까지 cpu가 어드레싱할수있다. 즉 이 cpu가 어드레싱 할 수 있는 디램의 최대용량은 64gb이다.
- 프로세서에서 말하는 스레드는 즉, 한 클럭 사이클에 작업할 수 있는 서로다른 프로그램(태스크)의 수
- 인텔 프로세서는 설계가 복잡해서 공정이 복잡하다. 메모리는 셀들이 바둑판처럼 깔려있어서 공정이 간단하다. 인텔은 지원해야할 칩셋이나 애플리케이션 장치들이 많아서 cpu장치가 복잡하다. 그래서 인텔 cpu은 항상 다른 프로세서보다 10~20%정도 오버헤드가 더 크다.

### 9. 웨이퍼(wafer)
- 이 웨이퍼는 크리스탈 실리콘이다. 이 웨이퍼에다가 공정을 해서 파고, 도핑하고, 빛으로 쬐소 패터닝 등을 하는데 이것을 공정이라고 한다. cpu가 아까 그 폴리곤들의 막대형태로 설계가 되면 그 형태대로 공정을 해서 웨이퍼에다가 만들어 논다. 그러면 웨이퍼에 있는 내모난 조각 하나하나가 다 cpu칩이다. 12인치(30센치) 웨이퍼 한장에 결함이 하나도 없을떄, cpu칩이 대략 280개 정도 만들수있다. 인텔은 yield가 상당히 높다 95~96%, ibm같은 서버용 회사들은 yield가 인텔보다 떨어진다.

### processor performance equation
- 컴퓨터의 성능을 수식으로 표현한 가장 중요한 식
- 컴퓨터의 성능은 어떤 프로그램을 실행했을때 실행시간이 결국 이 프로그램의 성능이다.
- 프로그램 실행시간을 구하는 식은 : T(프로그램실행시간) = NI * CPI * T
- NI는 한 프로그램에 있는 총 실행되어야할 명령어의 수이다.만약, 이 안에 명령어 수는 별로 안되는데 루프가 1000만번이라면, 실제 실행해야할 명령어의 수는 이 루프문 까지 포함하는 것이다. 즉 총 실행되어야할 명려엉의 수
- CPI는 명령어당 몇 사이클이 필요한가. 즉 IPC의 역이다. 한 명령어 처리하는데 몇 클락사이클이 걸리냐이다.
- T는 한 클락사이클의 시간이다.
- 다 곱해보면 단위가 s(초)만 나온다.
- 그러면, 컴퓨터의 성능을 높이려면 실행시간이 짧은게 좋다. 그러면 프로그램의 크기는 작아야하고 CPI는 작은게 좋고, IPC는 큰게좋다.
- T는 작은게좋다. T는 클락사이클 타임이고, 이것의 역이 클락스피드, 클락 주파수이다.
- 즉, 컴퓨터의 성능은 클럭스피드는 빠를수록, IPC는 클수록, 프로그램은 작을수록 좋다.
- 그러면 만약, 1GHz x86(CISC), 1GHz ARM(RISC) IPC도 모두 같을떄, 둘 중 누가 더 빠를까? RISC가 더 모던아키텍처이고 요즘 ISA가 모두 RISC구조로 되어있어서 RISC가 더 빠를껏 같지만, 그렇지않다. 왜냐하면, 두 CPU가 모두 IPC,클럭스피드가 같으면 프로그램 크기를 봐야하는데, 프로그램 크기는 CISC가 더 작다. 왜냐하면 CISC는 명령어의 수가 다양하고 종류도 많기 때문에 RISC가 3개의 명령어로 할 작업을 CISC는 1개로 처리가능하다. 즉, 프로그램 크기는 RISC로 하면 4~50%정도 더 커진다. 즉, 같은 클럭스피드, 같은 IPC이면 CISC가 더 빠르다. 왜냐하면 CISC가 명령어의 종류도 많고 다양하니까 프로그램의 크기는 작아져 실행해야할 명령어의 수는 작아지기떄문이다.
- 팬티엄과 팬티엄프로 비교 : 둘다 x86이므로 프로그램 크기는 같다. 클럭스피드는 팬티엄프로가 2배 빠르다. 하지만, 팬티엄프로는 팬티엄 보다 2way에서 3way이고, OOO이므로 IPC가 더 커졌기때문에 실제 성능향상은 클록속도의 2배보다 2배 이상으로 성능이 증가했다.
- 팬티엄프로(2세대)와 팬티엄4(5세대) : 클럭속도는 14배빨라졌지만, 성능은 10배정도 향상. 즉 IPC는 떨어짐, 왜냐하면 팬티엄프로 제너레이션에서 팬티엄4로 가면서 클럭속도는 40%정도 좋아지고 IPC는 떨어졌다. 왜냐하면 파이프라인이 단계가 더 많아서 더 깊어져서 CPu가 예측한 분기들이 취소될때 더 많이 취소되기떄문에 IPC는 떨어졌다.

### 11. SPEC
- spec은 standard performance evaluation cororation으로서, 컴퓨터 성능을 객관적으로 비교하기위한 제 3자의 비영리 단체이다. cpu 제조사들이 서로 모여서 비영리 단체를 만들고, 이 단체로 하여금 서로 공정하게 평가하도록 만든것이다. 
- cpu성능을 평가하기위한 벤치마킹을 speccpu라고하고 이거 말고도 그래픽 벤치마킹, 웹 벤치마킹 등이 다 따로있다.
- 예를들어 spec cpu2006은 두 개의 밴치마크가 있는데 하나는 pc용을 위한 c인티저2006, 서버용은 플로팅포인트2006이 있으며, 피시용 벤치마크에는 12개의 애플리케이션, 서버용은 18개의 애플리케이션으로 평가한다.
- 스펙80,85,...,06으로 오면서도 한번도 안바뀐 어플리케이션은 GCC이다.(gnu c compiler)
- 이제 SPEC단체에서 래퍼런스 머신을 하나 정해놓고 위의 애플리케이션을 모두 돌려서 초 단위로 기록한다. 그 후 테스트 CPU를 이 레퍼런스 머신과 비교해서 애플리케이션마다 몇배더 빠르냐로 SPEC RATIo를 구하고 그 다음에 이 Rati를 기하평균낸다.

## Instruction Set Architecture

### 1. 기계어
- 기계어도 프로그래밍 언어 중 하나이다. 하지만, 0과1로 프로그래밍 하기 어려우니까 사람이 사용하는 언어와 유사한 high-level 프로그래밍 언어를 개발해 놓고 이 컴파일러라는 traslator를 개발해서 c,java,python으로 개발을 하면 컴파일러나 인터프리터가 해당하는 machine의 ISA(기계어)로 번역해준다. 굳이 사람들이 0과1로 프로그래밍 할 필요없다.
- c언어는 컴파일러가 c언어를 기계어로 번역해준다. 이 과정을 컴파일이라고하는데, 이 기계어도 아키텍처마다 다르다는 것이다. 즉, x86, ARM 등 모두 사용하는 ISA가 다르다. 그렇기 때문에 컴파일러는 바로 기계어로 만들지는 않고 어셈블러를 통해 어셈블리어로 먼저 c언어를 번역한다. 대부분 컴파일이라고 하면 이 어셈블러 과정도 포함해서 말한다. JAVA는 컴파일러가 아니고, 인터프리터를 통해서 JAVA언어를 기계어로 번역하고, 실행한다. JVM은 자바버추얼머신으로서 자바의 인터프리터인데, 자바를 기계어로 번역하고, 이 JVM머신 위에서 직접 실행까지도 한다. 따라서 JVM만 있으면 어떤 컴퓨터에서든 이 자바를 실행할 수 있어서 호환성이 좋다.

### 2. 프로그래밍 언어
- 저레벨(기계어) 프로그래밍언어 : binary, IA32, IA64, ARM, MIPS, 
- 고수준(high-level)프로그래밍언어는 다음과 같이 분류할수잇다.
  - procedural(imperative) language : C, Pascal, FOTRAN
  - Object-Oriented Language : C++, C#, JAVA, Kotlin
  - Functional(declarative) language : Lisp, Scheme
  - multiple paradigm language(hybird, 위의개념들이 모두 있는 언어): Python, 
- 위의 고수준 언어에서 최초의 고수준 프로그래밍 언어는 imerative 언어이다. 이것이 최초의 프로그래밍 언어이다. 원래 머신인스트럭션의 역할은 기계명령어를 하나 실행하면 기계스테이스가 바뀐다. 즉, 기계어의 기본단위는 기계명령어이다. 하지만  고수준 프로그래밍 언어는 intruction가 아니라 하나하나를 statement라고 한다. 즉, 문장, 하나의 statement(문장)을 실행하면 machine state가 바뀌는거다. 이런 언어를 imperative language라고 한다. 그러다가 어떤 작업을 여러번 할 수 있으니까, 이 작업을 procedure혹은 function형태로 묶어서 이 procedure를 하면 해당하는 안에 있는 statement를 여러개 실행하고 그 결과만 받으면 되니까, 이런 procedure형태로 묶은 언어를 procedural language라고 한다. procedural 언어의 특징은 프로시져 안에 선언된 데이터 즉, 변수들도 프로시저 안에 스코프를 가지고잇다. 이 안에서만 이 데이터(변수)가 유효하다. 즉, imperative language의 발전된 형태가 procedural 언어이다. 시간이 지나고 이 둘다 과거의 것이고 비슷하니가 procedural 언어로 퉁친다. 이 프로시져언어의 대표적인 언어가 c언어이다. 이 c언어는 UNIX라는 OS를 개발하기 위해 만들어진언어다. 그전에 언어들은 너무 복잡하니까 쉽게 개발하기 위해 새로운언어를 개발한것이다.
- pascal, fotran 은 과학계산용 언어로 80년대 많이 제한된 교과서적인 언어이다.
- 여기서 더 발전해서 객체지향언어가 나왔는데, 프로시져언어는 프로시져형태로 코드를 묶어논것인데, 이렇게 하지말고 객체 형태로 묶어놓고 프로그램은 이 객체들 간의 인터렉션으로 본다는 것이다. 이 객체 안에는 데이터도 있고 함수도있다. 이러면 좀더 프로그램을 사용하기 쉽고 다른사람이 작성한 프로그램을 이용하기도 쉬워진다. 객체지향언어의 가장 기초가되는 언어가 자바이다. C++은 C를 객체지향형태로 한건데 실제로 내부적으로는 C++은 C와 같다.
- 이 (imperative)procudural language나 oriented language의 특징은 모두 어떤일을 하기위해서 절차를 명시한다. 즉 how를 descirbe하는데, 만약, 컴퓨터가 로봇이라면, 이 로봇에 일을 시킬려면, 일을 하는 절차를 일일히 명시해줘야한다. 하지만, Functional language는 보다 고급스타일의 언어인데 이것은 일일히 다 얘기하지않고, What만 명시하는것이다. 대표적인 언어가 Lisp가 잇다. 분야에 따라서는 이런 Functional 언어를 사용하는 분야가있다.
- 파이썬은 위의 개념이 모두 혼합되어있는 멀티 패러다임 즉, 하이브리드 언어이며 또한 인터프리터 형태로 되어있어서 컴파일 뿐만아니라 바로 실행도 할 수 있는 언어이다.
- 궁극적으로는 사람이 사용하기 가장 편한 자연어로 컴퓨터를 프로그래밍 할 것이다. 하지만 아직 완벽한 자연어로는 기술력이 부족해 프로그리맹하지못한다.
- 컴파일과 인터프리터 : 이렇게 자연어로 가까운 언어로 프로그래밍을 해놓으면, 기계는 이 프로그램을 이해할 수 없다. 예를들어, 우리의 c 또는 Java 와 같은 고급언어는 그냥 영문, 심볼로 된 아스키파일 일 뿐이다. 그래서 이 프로그램이 실행되기 위해서는 실행할 머신에 해당하는 아키텍처(ISA,기계어)로 트랜슬레이션 해줘야하는데 이 translator를 일반적으로 컴파일러라고 한다. 이 컴파일러는 즉, 고급언어로 작성된 프로그램을 해당하는 기계의 기계어로 번역해준다. 근데, 이 컴파일러는 단순히 번역만 하는거다. 그래서 이 번역을 다 하면 실행파일이 나오고 우리는 이 실행파일을 실행해서 프로그램을 실행하는것이다. 반면에 인터프리터는 translation과 동시에 바로바로 실행하는것이다. 즉, 번역과 동시에 프로그램을 실행하는것을 인터프리터라고한다. 우리가 pc에서 그래픽으로 아이콘을 더블클릭하면 이 프로그램을 실행하는것이지만 우리가 터미널을 실행하고 dos명령어로 타이핑할수있는데 이 명령어들도 다 구문을 가지고있다. 그러면, shell 인터프리터가 이 커맨드를 번역함과 동시에 실행도 하는것이다. 즉, 인터프리터는 쉘에 있는 인터프리터라고 생각하면된다. 즉, 번역만 하는것을 컴파일러 , 번여고가 동시에 실행하는것을 인터프리터라고 한다. 어셈블리는 컴파일의 일부분인데, 기계어는 0과1로 되어있어서 사람이 보고 이것을 해독하기는 굉장히 힘들다. 그래서 이 기계어와 거의 1:1로 매핑되는 심볼릭 머신랭기지 즉, 어셈블리어 (assembly instruction)는 거의 기계어와 1대1로 매핑되기떄문에 같다고 본다. 이런 어셈블리어로 된 프로그램을 0과1로 바꾸는 것을 어셈블러라고한다. 이것도 컴파일러의 일부이다. 인터프리터의 대표적인 예가 JVM(java virtual machine)인데, 기본적으로 자바로 작성된 프로그램은 2단계로 걸쳐서 실행이된다. 먼저 자바 컴파일러는 자바 프로그램, 즉 우리가 짠 자바 코드를 자바 byte code, 자바 바이트코드란, 자바가 생각하는 자바 virtual machine의 Instruction set이다. 이것은 실제 x86도아니고 ARM도 아니고 그냥 자바 가상 머신에서의 기계어이다. 이것을 자바 바이트 코드라고한다. 그러면 자바 컴파일러가 컴파일을 하면 자바 바이트코드가 생성되고 이 바이트코드가 자바 실행파일이다. 이 바이트코드는 JVM(인터프리터)이라는 가상 머신에서의 기계어이기때문에 자바 실행파일(바이트코드)을 실행하기위해서는 반드시 JVM이 있어야한다. 이 JVM의 역할은 자바 바이트 코드로 된 자바 프로그램을 다시 해당하는 머신의 instruction으로 번역함과 동시에 실행한다. 즉, 자바는 먼저 우리가 짠 코드를 JVM에서 돌아가는 바이트코드로 만들고, JVM이 이 바이트코드를 다시 해당하는 머신의 기계어로 번역한후 동시에 실행까지해준다. 이렇게 함으로써 어떤 컴퓨터건 즉 x86이건 arm이건 mips이건 JVM만 컴퓨터가 가지고 있으면, 자바프로그램을실행할 수 있다. 즉, 코드의 호환성이 좋다. (파이썬도 마찬가지로 파이썬 인터프리터가 바로 번역과 동시에 실행을 한다.) 인터프리터가 있으면 수정 사항이 발생하면 해당 코드부분만 수정하면 된다. 또한 호환성 문제에 대해 자유롭다. 컴파일러일 경우 수정한후 다시 컴파일해야한다.

### 3. 컴파일러
- 컴파일러는 일반적으로 A라는 언어로 작성된 인풋이 되는 소스프로그램(SOurce program)을 B라는 언어로 작성된 Target Program으로 traslate하는것을 말하고, 소스프로그램은 c,java,python같이 고수준 언어로 작성된 프로그램이고, 타겟프로그램은 우리가 실행하려는 머신의 mahcine language를 말한다. 그래서, 타겟프로그램에는 x86, arm, mips등 프로세서에 따라서 여러가지로 트랜슬레이션 할 수 잇다. 이 컴파일러도 컴퓨터과학에서 하나의 연구분야이다. 예를들어 c언어 컴파일러를 만든다고 생각해보자. 요즘엔 여러 툴이 있어서 소스프로그램을 타겟프로그램으로 번역해 실행까지는 할 수 있다. 문제는 이 컴파일된 프로그램이 타겟머신에서 얼마나 효율적으로 빨리 실행되느냐이다. 이것에 따라서 하루가 걸릴수도잇고 1초면 끝날수도있다. 예를들어, 곱하기8 하는데 진짜 곱하기8을 할수도있고 아니면 binary shift로 왼쪽으로 3만큼만 옮길수도있다. 또, 명령어의 순서를 바꾼다든지 해서 코드를 훨씬더 효율적으로 만들수도있다. 그래서, 컴파일러가 어떤일을해야하는가는 첫번째는 무조건 correct code. 즉, 원래 소스프로그램에서 (즉 c언어의 시퀀스)말한거랑 machin instruction의 시퀀스가 동일한 결과를 내놔야한다. 또한 실제 이 타겟프로그램이 얼마나 빨리 실행되느냐도 중요하다. 세번째는 컴파일이 얼마냐 빠르냐이다. 컴파일된 프로그램이 머신에서 1초 걸리다 해도 컴파일 되는 과정이 하루 걸리면 쓸모없는것이다. 또 4번쨰는 seperate compliation을 지원해야하느데 이 seperate compliation은 우리가 프로그램을 짤때 기본적으로 내프로그램만 되는게 아니고 프로그램이 크면 여러사람이 공동으로 프로그램을 작성해야할텐데 그러면 코드가 여러개로 분리되서 관련된 함수들이 하나의 파일로 각각이 따로 컴파일되어야할텐데 이것을 분리컴파일이라고 하고 뒤에 링킹에서 배운다. 또 5번째는 어디서 에러가 발생햇ㅅ는지 컴파일러가 정확히 알려줘야한다.
- 컴파일의 과정을 보면(c프로그램) 원래 소스프로그램은 아스키 텍스트파일이다. 여기시ㅓ #Include로 해더파일을 인클루드하거나 #define 등 const 등 매크로 , 즉 자주사용하는 어떤 매크로함수를 디파인한다. 이것은 컴파일 과정중 preprocessor(전처리기)가 이런 매크로를 (매크로는 실제로는 함수는 아니고, 사실은 text substitution)이다. 그니까 어떤 함수를 매번 일일히 쓰기 귀찮으니까 텍스트로 요약한 매크로함수를 만들어논것이다) 실제로는, 이 전처리기가 매크로함수들을 원래의 substitution으로 다시 대체해준다.(include같은 헤더파일도 포함) 전처리기가 다 텍스트들을 대체한 파일을 이제 컴파일하는데 이러면 오브젝트파일이 만들어지는데, 오브젝트 파일은 해당 c파일 하나를 컴파일한건데 0과1로 된 binary 즉, machine instruction의 시퀀스이지만, 이것은 아직 실행파일은 아니다. 왜냐하면, 보통 프로그램은 내가 짠 코드만있는것이아니고 라이브러리의 다른 함수도 콜하고 다른 사람이 작성한 프로그램과도 합치기때문에, 지금 이단계는 아직 프로그램의 한 조각일뿐이다. 이것을 relocatable object file(code)이다. 왜 relocatable이냐면 뒤에 링킹에서 배우겟지만, 오브젝트 파일들이 나중에 하나의 메모리영역에 적재되는데 이때 순서대로 카피할떄 위치가 ㄱ바뀔수 있다 (어떤순서로 들어가겟다던지) 그래서 이것을 reloactable code라고한다. 애내들은 실제로 실행하려면 얘가 다른 파일에 있는 어떤 함수를 콜할수도있고 어떤 라이브러리에 있는 것을 콜할수도있다. ㄱ래서 실제로 애네들은 아직 어떤 외부의 함수를 불러오지못한다. 아직 얘네 파일에는 없기떄문이다. 그래서 아직 이단게는 외부 라이브러리라든가 그런것들에대한 코드나 데이터는 아직 없는 단계이고 자기 코드만 0과1의 긱계어로 번역된 상태이다. 그러면 얘가 실행되려면 얘랑 연결되는 이 오브젝트 파일들 과 라이브러리에 이 파일이 사여용하는 부분들을 실제 사용하는 것만 가져와서 이제 다 연결되먄 이제서야 실행파일이 되는것이다. 그래서 우리의 소스프로그램이 컴파일을 거치면 얘는 하나의 실행파일이 아닌 오브젝트 파일이고 (오브젝트파일이란 0과1로된 바이너리인데, 아직 실행파일은 아니고 부분적인 조각) 이것이 링커라는 컴파일러의 다른 툴이 얘랑 연관된 다른 relocatable obj파일, 혹은 라이브러리에서 이 파일이 참조한 오브젝트 파일들을 쭉 묶어서 하나의 실행파일이 되는것이다.
- 코드 컴파일 과정에서 명령어 실행순서도 효율적으로 되도록 바꾸고 그런다
- Compiler Phrases : 컴파일러의 단계는 5단계의 순서로 이루어지는데, 첫번째로 프로그램이 들어오면 Lexical Analyzer -> Syntax Analyzer -> Intermediate Code Generator -> Code Optimizer -> Target Code Generator 의 5단계를 거친다. 여기서 4번쨰 코드 옵티마이저에서 해당 코드가 효율적으로 실행되로곡 코드의 배치를 바꾸고 명령어도 선택한다. 렉시컬은 코드의 관사를 정해주는 부분이다. 예를들어 원래 코드프로그램은 하나의 텍스트파일일뿐인데 렉시컬을 끝내면 a sequence of token이 된다. 영어로 빗댐녀 i ate an elephant라고 한다면, i 는 대명서, ate은 동사, an은 관사, elephant는 명사 이렇게 우리의 c 코드를 품사의 토큰 형태로 만들어주는것이다. 예를들어 for는 키워드, i는 identifier, 1은 constant는 이런식으로 토큰형태로 만들어준다. 그다음 Syntax Analyer는 예를들어 아까 i는 대명사인데, 이것은 주어이고, ate은 동사이고 elephant는 목적어가 3형식이 소스코드도 여러 토큰이 묶여서 하나의 statement를 만드는것이고 이 statement가 묶여서 하나의 procedure가 되는것이다. 결국 sysntax가 하는일을 이 소스코드 문장이 문법적으로 옮바른지, 아니면 올바른 단어인지를 체크하는것이다. intermidate code generator는 i ate an elephant는 문법적으로는 맞다. 근데 이게 의미적으로 맞냐는 것을 체크하는것이다. 그니까 소스코드를 밑에서 혹은 위에서 부터 전체적인 문맥과 함꼐 체크를 하면서 의미를 체크하는것이다. 이 과정을 거치면서 바로 타겟머신의 명령어가 만들어지는것은 아니고, 중간 코드라고해서 기계에 상관없이 표준적인 기계어 비슷한 형태의 중간 언어를 생성하는것이다. 여기까지가 프론트엔드이다. 왜 intermidiate 를 거치냐? 즉 바로 기계어를 만들면되는데 왜 거치느냐는 프론엔드를 두고 이것이 항상 표준적인 중간어를 생성하기로 해놓으면 예를들어 회사에서 이번에 arm용 c컴파일러를 만든다고 하면 이 중간언어가 없으면 처음부터 다시 만들어야하겟지만 프론트엔드(중간언어)가 있으니까 중간언어 부터 만들면 도니다. 그래서 프론트엔드는 그대로 가져다 쓰고, 백엔드부터 arm용으로 만들면되는것이다. 또 다른이유는 만약 우리가 c컴파일러를 가지고있는데, 이번에는 다른 언어의 컴파일러를 만든다고 생각해보자. 그러면 우리가 이미 arm용 c컴파일러가있으니까 여기서 백엔드는 그대로 두고, 프론트엔드만 만들면 다른언어에 대한 컴파일러도 만들수있는것이다. 그래서 프론트엔드와 백엔드를 나눈것이다. 이제 프론트엔드를 다 거치면, 원래 소스코드의 의미를 정확하게 반영할수 있는 상태만 된것이다. 이제 이 백엔드(코드 옵티마이저)를 거치는데 여기서, 이 해당하는 머신이 2-way, 3-way 슈퍼스칼라인지 여기에 맞춰서 코드를 잘 생성해야한다. 3-way면 병렬로 3개씩 해서 명령어를 3개씩 실행할수있게해야하는데 만약, 3-way인데 아무생각없이ㅣ 명령어 사이에 dependancy를 강하게 해놓으면 3-way인데도 하나씩 밖에 명령어를 실행할 수 박에 없다. 그니까 이러한 병렬성을 고려하거나 , 아까말햇듯이 곱셈대신에 시프트 연산을 한다던지 등 여러가지 코드최적화를 통해서 이 머신에서 가장 빨리끝낼수있게 코드 최적화를 하는 부분이다. 이 프론트엔드까지는 대부분 자동화가 되어있고, 뒤에 백엔드부분이 가장 어려운부분이다. 이 백엔드 부분이 머신에 대해서 최적화를 해줘야한다, 머신도 같은 아키텍처라해도 마이크로아키텍처는 다르기 때문에 여기에따라서 코드최적화도 다르게 해줘야한다.

### 4. Machine State
- 이제 우리가 ISA라고하는것은 기계어들의 집합이니까, 이제 이 명령어 집합들만 정의해주면 되는데, 이 명령어 집합들을 정의해주려면 머신 스테이트를 정확하게 디파인해야하기때무ㄴ에 우리가 ISA라고 하는것이다. 그래서 이 ISA는 정확하게 우리가 Instruction Set뿐만아니라 machine state도 정의하는것이다. 이 machin state에는 무엇이 이쌰면, 뭐 레지스터나 메모리 와 같은 것들이있다. 명령어의 역활은 레지스터를 변경하던지 아니면 메모리의 상태를 변경하든지로 크게 나눌수잇다. 레지스터란 우리가 논리회로에 배운 sr래치로 만들고 클럭이 들어오면 이 클럭을 가진 플립플롭으로 만들고 (edge-triggered F/F) 플립플랍 하나가 1비트의 정보를 기억하는데 클락을 가진 회로에서 32비트 레지스터는 32개의 플립플랍이다. 그러면, 32비트 머신에서는 기본적으로 연산의 단위가 32비트(덧셈뺼셈곱셈나눗셈)을 하는데 기본적으로 메모리에서 데이터를 가져올떄도 한 word는 32비트이고 risc프로세스의 경우에는 일단 cpu안에있는 레지스터를 읽어온 다음에 그다음 연산을 할 수 잇는 그래서 메모리로 부터 읽어온것을 cpu내부에 저장할 장소가 잇어야하는데 이 장소를 레지스터라고 한다. 이 레지스터가 하나만 있으면 불편하니까 인풋을 더하려만 해도 2개를 읽어야하는데 레지스터가 하나만잇으면안되고 기본적으로 mips 같은 32비트 프로세서의 경우 레지스터는 32개가 잇고 x86같은 경우는 cisc고 오래되었기 때문에 이 때는 프로그래머가 사용하는 레지스터가8개 밖에 없었다. ia64는 최근에 만들어진 새로운 ISA인데 ia64는 128개의 레지스터를 가지고잇다. 그래서 우리가 좀더 편리하게 레지스터를 활용할수잇다. 그래서 레지스터란 메모리로 부터 펫치한 데이터를 저장하는 시피유 내부의 저장소이고, 레지스터는 대부분 하나의 사이클에 읽거나 쓸수잇다. 항상그런거는 아니고 128개정도로 많은 레지스터면 한 사이클에 안끝날수도있다. 컴퓨터는 왜 컴퓨터라고 하냐, 컴퓨터의 기본작업은 그냥 메모리로부터 읽어와서 덧셈뺄셈하고 다시 메모리에 쓰는것 그것 뿐이다. 하지만 이것을 굉장히 빠르게 하기때문에 우리가 생각하는 모든 작업을 다 프로그램으로할수잇는것이다. 하지만 연산을 하려면은 일단은 메모리로부터 레지스터로 읽어와야하고 이런 컴퓨터 연산 덧셈뺼셈곱셈나눗셈등은 레지스터에 저장되어있는 데이터에 대해서 수행되어질수 있다 이것이 risc 프로세서의 기본 철학이다. (LOAD/STORE) x86의 경우 메모리에 대해서도 연산할수잇는데, x86을 빼고 요즘 프로세서들은 이것으 허락하지 않는다. 먼저 가져와서 연산하고 저장하는 것만된다. 그래서 우리가 mips 라는 risc프로세서에서는 32개의 32비트 레지스터를 가지고있다. 각각의 레지스터는 32개의 플립플랍이다. (왜냐하면 1비트레지스터가 1개의 플립플랍이니까) 레지스터는 컴퓨터 메모리안에서 가장 빠른 메모리이다. 왜냐면 cpu 코어 안에있고 몇개 안되기 떄문에 빨리 읽고쓰고할수잇다. i7의 경우 코어안에 lv1 캐시, lv2 캐시가 있다. 이 캐시는 명령어나 데이터를 메모리에서 가져와서 버리지않고 임시 저장해놓는것이다. 왜냐 재사용할 가능성이 크기때문이다. lv1은 더 가까이 있는거고 lv2는 좀 더 바깥에 있는것이다. lv1, lv2 캐시는 cpu 코어 안에 있는 것이고, lv3 캐시메모리는 cpu칩 안에 코어 바깥에 있다. 왜냐면, 메모리를 접근하는것이 점점 느려지게 떄문에 이런 캐시가 만들어진것이다. 가장 빠른 메모리는 레지스터이다. 레지스터라는 것은 프로그래머에 visible한데, 캐시는 invisible하다. 우리는 결국 프로그램할때는 load하면 메모리로부터 레지스터로 읽어오는 것이다. 이 메모리가 디스크인지 메모리인지 캐시인지는 우리는 모른다. 이 메모리는 결국 , 즉 프로그래머가 보는 이 메모리는 결국 프로그램이고 프로그램이란것은 결국 a sequence of instruction이고, 이것과 관련된 데이터들을 포함하는것이다. 그래서 프로그래머 입장에서는 이 메모리를 가상메모리라고 하는데, 이 가상메모리라는것은 그냥 프로그래머가 생각하는 메모리일뿐이다. 근데 실제로 이 메모리그는 어떤 경우는 캐시에서, 어떤경우는 메인메모리, 어떤경우는 하드디스크 혹은 클라우드 에서 가져올수있는것이다. 그래서 DRAM만 physical memory라고하고 프로그래머입장에서는 캐시인지 디렘인지 디스크인지 고려하지않고 그냥 가상의 메모리라고 가정한다. 그럼 프로그래머의 입장에서는 load할떄 load하고 메모리 몇번지에서 레지스터 1번으로 가져와라 할떄 이게 알고있는 메모리는 가상메모리, 주소, 레지스터 이게 다 다. 즉 프로그래머입장에서 visible한것은 레지스터이고 (가상)메모리이다. 왜냐면 우리가 load할때는 메모리로부터 레지스터 이게 다이기 ㅂ떄문이다. 이 메모리는 가상메모리이다. 그래서 레지스터는 프로그래머가 specify한다(어떤 레지스터를 읽어ㄹ와라 등), 하지만, 캐시나 이런거는 하드웨어가 알아서 정해준다. 프로그래머입장에서는 캐시가 있고없고 생각하지 않는다. 다만 캐시가 있으면 더 빠를뿐이다. 프로그래머입장이라는 것이 machine instruction 입장이란 말이다. machine instruction입장에서는 그냥 레지스터와 메모리 일뿐이다. 그래서 이 메모리 라는것은 가상메모리이다. 이 메모리라는 것은 프로그래머 입장에서의 메모리 혹은 프로세서의 입장에서도 마찬가지이다. 메모리라는것은 그냥 가상의 메모리이고 이것은 0번부터 32비트 주소이면 2^32-1번지 까지의 linear array of byte이다. 왜냐하면, 모든 바이트 마다 주소를 갖는다. 우리가 메모리에서부터 입출력할수있는 가장 최소단위가 바이트이기 때문에 바이트 하나마다 주소를 갖는거다. 우리가 c언어에서 getchar()하는데 이것은 기계어로번역하면 LOAD byte이다. byte(메모리주소), 즉, 메모리라는것은 32비트주소이면 그러면 2^32-1번지까지 주소를 갖는것이고, 이 주소가 가리키는 메모리의 최대공간은 2^32바이트이다. 주소 번지가 0번지부터 2^32-1번지까지 있으니까 2^30이 1gb이니까 2^32은 4기가바이트 이다. 이 말은 프로그램의 최대크기가 4기가바이트라는 것이다. 프로그램이란것은 명령어와 데이터들의 시퀀스이다. 그래서 32비트인 x86아키텍처에서는 프로그램의 최대 크기가 4기가바이트를 넘지못한다. 그래서 프로그램이 4기가보다 더 커지면 64비트로 바꿔야한다. 그래서 이 한계가 2000년 쯤부터 발생해서 인텔은 ia64로 준비를 한것이다. 근데, 인텔은 과거 cisc로 고생을 많이해서 디지털 알파칩, 또는 다른 risc에 비해서 오버헤드가 더 크다(복잡해서) 즉, 성능이 좀 안나오고 복잡ㅎ다가. 근데, 이 cisc를 최대한 risc프로세서 같이 만든것이다. 근데 이 펜티엄프로세서하면서 서버시장의 성능을 능가햇다. 그러다가 프로그램크기가 점점커지니ㅏㄲ 앞으로 64비트의 시대가 될거라고 생각해서 (4기가로는 모자라서) 그래서 64비트 머신으로 가야하는데 인텔은 ia64를 사용한것이다. 이 ia64는 cisc도 아니고 risc아니고 훨씬 더 발전된 머신 언어를 만들겟다는 포부를 가지고 만든 기계어인데, 너무 욕심이 많아서 많은 것을 넣어서 너무 복잡해지게되었다. 사실 원래 x86은 엣날에 ibm이 컴퓨터를 만들다보니까 인텔이 만든 프로세스(x86)을 쓰면 개인용 피시도 만들수잇을것 같아서 이걸 장사를하려고 인텔한테는 cpu만들고, 마이크로소프트한테는 os를 맡기고, 자기가 pc를 만들겟다고 해서 시작한것이다. 그래서 인텔의 프로세스 IA32는 항상 ibm이 라이센스를 가지고 있고, 이 라이센스를 다른회사한테 줄 수도있다 처음에 계약을 이렇게햇다. 그래서 이러다 보니까 인텔 뿐만아니라 amd한테도 이 라이센스를 줘서 여러 회사들이 x86을 사용해삳. 근데 인텔은 정말 잘 만든 거니까 자기가 혼자 쓰고 시퍼서 앞으로는 ia64로 바꾸고 이거를 전부 자기만 쓰려고 막아두었다. 그래서 이제 x86을 쓰던 amd는 이제 새로운 기계어를 만들려고 보니까 규모가 작아서 64비트로 가야하는데 인텔은 이걸 자기들 꺼라고 안주니까, 그냥 원래 쓰던 x86 을 데이터크기만 64비트로 늘려서 amd64로 먼저 만들어서 64비트 시장에 들어갓다. ia64는 아직 상용화된 프로세서 (itanum)이 출시되지는 않았다. 근데 amd64가 너무 잘팔려서 인텔도 ia64를 고집하다가는 64비트 프로세서 시장을 잃을것같아사 x86-64로 프로세서를 만들어 출시한것이다 . 즉 x86-64가 amd64를 쫒아간것이다.
- 그래서 메모리 라는것은 프로그래머 입장에서는 디스크건 메모리건 캐시건 상관없이 그냥, 0번지 1번지,.. 번지마다 한 바이트씩 가는 linear byte array일 뿐이다. 이 주소의 크기가 프로그램의 크기를 결정하는 것일 뿐이다. 그래서 이 메모리에는 프로그램이 저장되어잇는데 이 프로그램이라는것은 결국 명령어와 데이터들의 시퀀스 일 뿐이다. 프로그램의 크기를 애기할때는 프로그램 안의 코드(명령어)와 데이터를 모두 포함해서 애기하는것이다. 왜냐 가상메모리라는것이 사실 code영역에 machine instruction들이 있는거고 나머지(data, stack)는 전부 데이터들이 있는곳이다. 실제로는 코드보다 데이터가 더 크다. 그래서 실제 이 영역들이 전부 프로그램이고 이것들이 저장된 영역이 가상메모리이다. 그래서, 메모리라는 것은 위에서 본 이 가상메모리 라고 하고 이 가상메모리에는 명령어(코드)뿐만아니라 데이터들이 저장되어있는 영역이다. word는 연산의 기본단위를 말한다. 만약, 32비트 프로세스를 가정하면 1word는 32비트고 double word는 64비트이다. mips도 ㅣoad명령에서 읽어오는 데이터의 크기를 load에서 지정해줄수잇는데, 기본적 load는 32비트이고, load byte, load double 등을 할수가 있다. 그러면 , 레지스터 2개가 카피되는것이다. 즉, 읽어오는 단위를 명령어에서 명시할수잇다. alignment란, 메모리에 저장된 데이터나 명령의 주소가 시작하는 주소가 자기 데이터나 명령어의 크기에 배수에 저장되어있다. 예를들어 워드면은 32비트머신에서 1word이면, 0,4,8,12 처럼 4의 배수에서 시작하는 주소를 가지고있다. 그러면 double word는 32비트머신에서는 8바이트인데 이것은 0,8,16 즉 8의 배수에서 시작되야한다. MIPS는 32비트 4바이트니까 4의배수에서 시작해야하고, char같은것은 1바이트니까 아무데나 저장될수잇다. 즉, 모든 데이터마다 데이터 크기의 배수에 시작해야한다. 이것을 얼라인 되어졌다고 한다. 만약 코드가 위의 언라인을 지키지 않고 미스얼라인 되어이스면 이 프로그램은 실행이 불가능하다(대부분), 컴파일러가 대부분 이렇게 직접 얼라인 되게 저장ㅎ을해논다. (워드랑 레지스터의 사이즈는 항상 같다) 즉, 우리가 쓰는 i7은 다 64비트 레지스터다. 근데, i7도 x86인데, x86은 프로그래머가 생각하는 레지스터는 8개 뿐이다. 그래서 실제로 레지스터가 8개는 너무 작은데, 하드웨어 레지스터 리네이밍에 의해서 실제 물리적인 레지스터는 물론 8개보다 많기떄문에 이 리네이밍에 의해서 많은 레지스터르 사용할수잇다. 


### 5. Machine Instruction
- 기계명령어는 크게 2가지로 나뉜다. 하나는 오퍼레이션, 하나는 오퍼레이션의 대상이되는 데이터. 즉 오퍼랜드, 결국 데이터는 하나의 입력이고 대부분 이 입력 2개를 읽어서 하나의 출력을 만든다. (destinateon) 이 출력이 state를 변경하는것이다. 그래서 OPcode는 실제 수행할 Operation을 명시해주고 거기에는 덧셈,뺼셈,곱셈,나눗겜, 또는 메모리로 부터 레지스터로 읽어오는 LOAD, 그 반대인 STORE, JUMP 는 프로그램 명령의 순서를 바꿔주는 명령어인데 이거는 브랜치명령어라고 한다. c의 if then else, swith, for loop, while loop 등을 말한다. 이런것을 오퍼레이션이라하고 나머지는 이 대상이 되는 데이터 즉 오퍼랜드라고 한다. 입력이 되는 데이터를 source라고 하고 아웃풋이 되는 데이ㅓㅌ를 destination이 된다. 그러면 load하게 되면 인풋은 메모리이고, (메모리의 어떠 ㄴ주소) destination은 레지스터, store는 인풋(소스)은 레지스터이고, desti은 메모리, add 이런거는 우리가 computation은 레지스터에서만 할 수 잇는데, 그래서 add 는 input, ouput들다 레지스터가 되는것이다. 레지스터는 어떻게 명시하냐면 레지스터 번호로 명시할수잇다 예를들어 mips에는 32개의 레지스터가 잇으니까 이걸 명시하려면 5비트가 필요하다. 그래서 레지스터 operand는 레지스터 번호로 명시할수잇고 근데 메모리는 뭘로명시하냐면 주소로 명시해야하는데 주소가 32비트니까, 명령어의 길이가 32비트, 즉 32비트 주소를 다 얘기해버리면 명령어에 명령어를 지정해줄 칸이 부족하고 주소 칸에 다 써버려야한다. (즉, 다른 opcode같은거는 칸이없다)그래서 메모리 주소를 지정하는 방법이 따로잇는데, 이것을 memory addressing이라고한다 . 이 방법은 대게 레지스터r에 있는 어떤 값에다가 8을 더해서 그걸 주소로 삼는 방법들이 잇다 뒤에서 더 자세히 배운다.

#### instruction type
- 모든 machine instruction은 크게 3가지 타입으로 나눌수잇는데, 가장 기본은 arithmetic logic instruction(operation)인데, 이것은 계산 근데 단순히 산술연산뿐만아니라 논리연산도 한다. 즉, 레지스터 둘을 exclusive-OR할수도잇고 and(bit by bit) 할수도 있고 Or할수도잇고 shift할수도있다. 그래서 실제 레지스터 오퍼랜드에 대한 연산을 한다. add, multiply, divede, sqrt도 있다 대부분, 그리고 모든 논리연산등을 처리할수릿다.
- 그 다음에 이제 우리가 보통 레지스터가 일반적으로 pc에 사용하는 레지스터가 2개가 있는데, 하나는 정수 레지스터, 하나는 실수레지스터가잇는데 정수 게산과 실수게산은 완전히 다른 설계를갖는다. 그래서 정수 계산을 위한 장치를 ALU라고 하고 부동소수점 계산을 위한 장치를 Floting point Unit이라고 하고, 이 대상이 되는 레지스터도 정수 레지스터와 부동소수점 레지스터 가 따로있다. 그래서 ia64같은 itanium은 128개의 정수, 128개의 부동소수점 레지스터가 잇다. 정수 레지스터가 일반적인 레지스터 이므로 general purpos register라고 하고 추가적으로 부동소수점 연산을 위한 레지스터는 부동소수점 실수 데이터를 저장하는 레지스터가 따로잇는것이다. 일반적으로는 32개의 레지스터를 가지면, 32개의 정수 레지스터와 32개의 부동소수 레지스터가 따로잇다.
- 결국에는, intstruction type은 오퍼레이션이 어떤 오퍼레이션이냐 즉, 오퍼레이션 타입, 오프코드 타입에 따라 달라지는것이다. 컴퓨터는 기본적으로 계산하는것이니까 기본적으로 계산에 필요한 명령어들이 주를 이루고 나머지는 계산을 위해서는 데이터를 읽어와야하니까 이 명령어를 Data transfer intruction 혹은 (memory instruction)이라고 한다. 여기에는 load, store가 있다. 근데 이 loade, store 2개만 잇느게 아니고 Load word, byte, 등등 데이터 크기마다 다 다르다. 그리고, ㅍ로그램이 저장된 메모리 영역에 데이터들중 일부는 메모리 영역의 일부는 i/o 장치에 연결되어있다. 그니까 이 i/o장치에 연결되어잇는 메모리를 load하면 입력이 되는것이고 이거를 store하면 출력이 되는것이다. 그러면, 그냥 load'/stroe만 하면 입/축력을 하는것이다. 그니까, 우리가 키보드 입력을 하면 키보드 인터럽트가 걸려서 한 문자 씩 입력이 되는것이다. ㅇ리가 아무리 키보드를 빨리해도 컴퓨터 입장에서는 굉장히 느린ㄷ것이다. 입력이 되면 이 키보드에 해당하는 그 i/o포트 주소로 읽어오는것이다. 결국 i/o 장치는 메모리 주소에 맵 되어있어서 과거 옛날에 초창기 cpu에는 i/o를 처리하기 위한 명령어가 따로있었는데, 나중에 보니까 i/o장치도 많아지고 하니까 굳이 이렇게 입출력 명령어를 만들기보다는 메모리 주소에 입출력장치를 연결하면 된다는 것이다. 이런 입출력에 맵 된 메모리를 memory-mapped io라고 한다. 그래서 이 주소를 포트 라고 한다.
- 나머지 세번쨰는 control transper instruction(branch instruction)인데, 이것은 프로그램의 명령어의 순서를 바꿔주는 바꿔주는 명령어이다. 이것이 없으면 프로그램 명령어를 그냥 순서대로 하다가 끝나버린다. mips 같은 경우는 4바이트니까 pc가 가리키는 명령어를 하나 가져와서 pc는 그다음에 4씩 증가하면 된다. 그다음 명령어는 4ㅏ이트 뒤에 있을테니까. 사실 모든 명령어는 machine state를 변경하는것이다 computation을 하면 machine state가 변하고 load를 하면 machine(register) state가 변하고, store를 하면 machine(memory) state가  변하는 것이다. 그러면 이 브랜치 명령어는 뭐를 바꿀까? 순서를 바꾸니까, 즉 program counter 이 프로그램카운터는 cpu가 실행할 다음 명령어의 주소를 가리키는 레지스터인데 이  세번쨰 명령어는 이 pc의 상태를 바꾼다. 이 progrma counter라는말은 폰 노이만, 컴퓨터의 가장 대부는 앨런 튜링이고 두번쨰 대부는 폰 노이만 정도인데, 요즘의 현대식 컴퓨터는 모두 폰노이만 구조이다. 앨런튜링과 폰노이만이 서로 제자관계이다. 폰노이만이 IAS라는 프린스턴 대학교의 컴퓨터를 만들었는데 여기서 프로그램카운터와 같은 용어들이 처음으로 만들어졌다. 그전까지는 프로그램을 입력하려면 굉장히 복잡했는데, 폰노이만이 프로그램을 메모리에 저장하고 거기서 불러오자는 store-load개념을 최초로 도입해냈다. 결국 브랜치명령어는 우리가 간접적으로 이 브랜치명령어를 실행함으로서 PC 값을 바꿀수있는것이다. 이 프로그램카운터는 눈에보이지않는 특별한 레지스터이다. 이 브랜치명령어는 크게 condition을 가진 것과 가지지 않는 것이 있는데, if== 가지지않는 것은 unconditional 브랜치로 그냥 해당 주소로 가는 것을 맗나다. 이 브랜치명령어의 예로는 JUMP, JUMP는 예를들어 go to 즉 어떤 명령어 주소로 바로 보내는 명령어이고, call은 function call 혹은 프로시저 콜, return은 function이나 프로시저 끝에서 다시 돌아오는 것을 말한다. BEQ는 branch EQㅇ르 말한다. 같으면 해당주소로 이동 (크거나 작거나 모둗 ㅏ잇다)
- 이런 명령어 들이 이쏙, 이것들이 32비트 명령어 안에 0과1로 인코딩되어있는것ㅇ디ㅏ.그럼 32비트 명령어 안에 어떤필드는 오퍼레이션 코드, 어떤 필드는 오퍼랜드 필드를 나눠서 우리가 명시를해줘야한다. mips는 risc라 intruction format이 딱 3가지 뿐이다. x86은 훨씬복잡하다. r타입이라는 것은 레지스터 포맷이라는걸 말하고 모든 arithmetic logec instruction 은 이런 r-type으로 인코딩되어잇다. op는 opcode를 말하는거고 6비트이고, 사실 맨 밑에 func필드 이것도 op코드랑 같은 역할을하는데, r-type같은경우에는 이 Op는 6비트로 모두 0이고 나머지 63개는 i,j타입의 명령어로 사용이되는것이다. 즉, arith-log instruction은 op코드는 그냥 0이고, funct에서 64개의 arithmetci logic instrcution을 명시해주어 구분하는것이다.. r타입은 function필드를 쓰지만, i,j타입은 펑션필드가 없고 op코드만 쓰는데 그러면 r타입만 이렇게 op코드가 나눠저있는건데 그러면 이제 operation이 이렇게 되있으면 64개의 명령어 타입만 정의할수잇는데, 이렇게 나뉘어져있으면 총 몇개 정의할수잇냐면 , 127개의 명령어를 정의할수잇다. rs, rt, 인풋이 되는 레지스터이고 rd는 데스티네이션이 되는 레지스터이다. 그래서, shamt는 시프트연산에만 사용한다.
- 그래서 risc는 하나로 하던 명령어가 여러개로 해야하니까 프로그램 사이즈는 좀 더 커질 수가 있다. 하지만, 프로세서 처리 할때 로직이 좀 더 단순해지니까 클럭속도가 약  빨라지고 프로세서의 전반적인 속도가 30퍼정도 빨라진다.
- 명령어라는 것은 프로그래머가 기계한테 어떤 작업을 시키고 이 작업은 대게 연산이고 이 연산을 위해 메모리에 있는 데이터를 프로세서에서 읽어오고 다기 메모리에 쓰기, 그래서 명령어의 타입은 메모리에서 가져오거나 갔다쓰는 메모리 트랜스퍼 ㅁ여령어 혹은 al로직 명령어, 혹은 브랜치 명령어 이렇게 3가지 타입이있다. 이 명령어의 기본적인 구성은 op, 즉 명령어와 이 명령어의 대상이 되는 데이터이다. 결국에는 risc는 연산을 하려면 cpu안에 레지스터에 대해서만 연산을 할 수 잇다. risc도 메모리에 대해 연산을 할수잇지만, (cisc)처럼 이러면 프로세가 너무 복잡해지니까 그럴필요없이 cpu내부의 레지스터에대해 연산을 해야한ㄴ다. 즉, 연산을 할떄필요한것은 어떤 명령어인지와 인풋과 아웃풋 즉 오퍼랜드, 즉, 32비트 명령어 안에 오퍼레이션과 오퍼랜드를 어떻게 인코딩 (0과1로)할것인가. 그러면 오퍼레이션을 나타내는 필드를 Op코드라 하고 나머지는 오퍼랜드를 식별하늑서이다. 우리가 연산, 즉 al operation을 speicfy하려면 인풋.아웃풋 오퍼렌드들은 전부 레지스터, 그러면 레지스터가 최소 3개 ( 직 인풋2개 아웃풋1개) 그것이바로 rs, rt ,rd 이다. 여기서 rs, rt가 소스레지스터인데 이게 5비트로되어있는데, 이게 5비트로 레지스터를 충분히 구분할수잇다는것이다. 즉 여기서 mips는 5비트니까 레지스터가 32개의 서로다른 레지스터라는 것이고 그리고 이것이 32비트 프로세서니까 레지스터의 길이도 32비트고 (기본연산의 단이ㅜ) 그래서 rs, rt는 인풋이 되는 레지스터이고 rd는 목적지(데스티네이션)레지스터이다. 그러면 산술연산 명령어이니까 rs, rt, rd만 되면 오퍼랜드를 전부 specify할 수 잇다. 그리고 op코드가 6비트니까 op코드는 64개인데, 사실 64개 명령어는 좀 작다. 근데 128개를 하려면 7비트를 해야하는데, 이 7비트는 컴퓨터에서는 8의 배수, 혹은 4, 8, 등 짝수는 괜ㅊ낳은데 7비트는 좀 그러니까 오퍼레이션을 6비트로 하고 하지만, r타입인 경우에는 Op코드는 모두0이고, 대신 실제 operation은 funcfiedl로 하는거고, 여기에 AdD나 multiply 등 이런 al로직이 func필드로 specify하는것이다. 그래도 5비트가 남는데, 여기는 shfitamount인데, 이것은 shift는 상수로 하는데, 그니까 레지스터에서 값을읽어오는게 아니다. 그니ㅏ까 shift R8,R9 이것이 아니고 shift R8, 32이런식으로 옆에 shfit할 양을 상수로 적어준다. 그래서 레지스터가 32비트니까 5비트만 있으면 이 32비트를 커버할수잇다는 것이다. 이 shfit는 0부터 32비트는 5비트면 다 커버할수잇다는것이다. 그래서 5비트를 남겨둔것이다. shift를 위해서. 이 shfit할떄 몇비트는 상수인데. 즉 어떠 ㄴ레지스터를 몇 비트 shfit할것인ㄴ지 명령어 안에 상수를 인코딩해야하는데 이 상수를 인코딩한것을 immediatE 라고한다. 보통은 메모리에서 상수값을 가져오는데 이렇게 상수를 직ㄱ접 입력한것을 immediat이미디엇이라고한다. 즉, shift R2 3이런식으로 , 
- 그러면, 이제 r-type은 레지스터타입이라는것이고 오퍼랜드가 모두 레지스터니까, al명령어에 사용하는 명령어 형식이라는것이다. 그래서 r-type의 예제를 보면, add명령어를 r-type으로 나타낼수잇다. 그래서, 우리가 기계명령어 인코딩하려면, al명령어는 op코드는 전부 000000이고, 그다음 함수테이블을 보고 인코딩하면된다.
- $는 Resigster할때, R2이럴때도 있지만, $로 할수도잇다. 맨 왼쪽에 destination이다. 9,10번 레지스터를 읽어서 8번 레지스ㅓ에 저장해라 그럼 9번10번이 source1 source2이고, rs가 소스1, rt가 소스2이다. 그래서 9번 rs, 10번 rt, 8번이 rd, 그리고 immediate은 shift에서만 사용하니까 0, 
- 그러면 이제 0과1로 끊어서 이진수로하면 너무 길어지니까 나중에 어셈블리 프로그래밍을 하면 16진수로 한다. 너무 기니까, 그래서 4비트씩 끊으면 012A4020이다.이것이 add $8,$9,$10인것이다.
- 그래서, 사실 mips도 그렇게 이런게 0과1로 되었기 때문에 복잡한거지 다 알고나면 단순하다. 어셈블러는 어셈블리 명령어를 기계어로 번역하는건데 이거는 거의 1대1이니까 어셈블러는 컴파일러보다 훨씬쉽다.
- 지금까지가 r-type인데 이걸 사용하면 al명령어는 해결이 되는데 이제 2번쨰 데이터 전송명령어 load/stroe같은건데 이런것들도 op코드가 필요한다. 로드, 스토어도 데이터의 크기에따라 종류가 많다. 이거는 그냥 op코드로 인코딩하면되는데 근데 메모리 전송 명령어는 하나는 메모리 오퍼랜드고 하나는 레지스터 오퍼랜드인데, 메모리잇는것를 레지스터로 가져오던지 이건 load이고 레지스터를 메모리로 store하든지인데  그럼 2개의 오퍼랜드가 필요하다. 그래서 하나는 rt는 레지스터 오퍼랜드 rs, address는 메모리 오퍼랜드다. 이 메모리 오퍼랜드를 어떤 메모리로 부터읽어서 어떤 레지스터로 가져와라 이런것인데, 이걸 주소로 메모리를 명시한다. 일반적으로 32비트프로세서면 주소도 일반적으로 32비트다 밉스의 주소 공간은 그래서 0이 32개부터 1이 32개 즉 4gb인데, 그래서 메모리의 어떤 주소로 부터 읽어와라 할때는 32비트 주소로 명시하면된다. 그러면 opz코드 6비트에 메모리만 32비트 주소가 들어가면 명령어ㅡ이 길이가 길어지기때문에 ,  그래서 x86은 op코드에 메모리 주소도 다 들어있어서 명령어의 길이가 들쑥날쑥 한것도 많다.r 근데 risc는 전부 32비트로 통일이니까, 그러면 메모리의 주소를 어떻게 명시할것인가를 알아야하는데, 메모리의 전체 주소 32비트를 다 쓰면 너무 길기때문에 그래서 메모리의 주소가 곧 데이터의 주소인데 이 데이터의 주소를 base addressing ㅈ즉, 메모리 주소 32비트를 32비트 명령어에 인코딩하면 명령어 길이가 초과하기때문에 base 레지스터를 두고 여기서 어떤 값을 더해서 메모리의 주소를 결정하는 것이다. base는 메모리의 어떤 기준이 되는 그 주소로 부터 16비트 offset을 더하면, rs라는 것은 32비트 레지스터이니까, rs안에는 32비트의 어떤주소가 잆는데, 여기서 offset이 100이면 즉, 1000번지면 1100번지로 부터 읽어오겟다는것이다. 이게 머냐면 예를들어, 우리가 a1000이라는 배열이 있다면, a0를 어던 베이스 레지스터에 놓고  시작주소를 놓고, 여기서 4바이트짜리 정수 배열이라면, 각각이 정수이니까 a100이면, +400을 하면 도니다. 그러면 이 400을 여기 명령어 address에다가 저장하면된다. 즉, 메모리 주소를 직접 표현하지않고 베이스 레지스터의 내용에다가 오프셋을 더한것으로 주소를 결정하고 이것을 base addressing이라고 한다. 이 베이스 어드레싱은 mips뿐만 아니라 대부분의 프로세서에도 다잇다. 레지스터에있는 내용에다가 어떤값으 더해서 그걸로 주소를 하는것,
- 그러면 rs라는 베이스 레지스터에 저장되어있는 어떤 값인지는 모르지만, 32비트 주소에다가 address를 더하는데, 이것은 offset 혹은 displacement라고 한다. aka = also known as, 그러면 여기다가 오프셋은 4, 400, 4000도 될수잇는데 근데 이 값은 2의보수 형태로 포ㅛ현되기 땜누에 +,-모두 될수잇다. 즉, 뒤로도 갈수잇다. 즉, rs의 내용에다가 어떤값을 더한값을 메모리의 주소가 되는것ㅇ디ㅏ. 결국 이 메모리 주소를 rt에 저장하는것ㅇ디ㅏ. load는 rt가 목적지인데, store는 rt가 소스가 된다.
- 즉, op코드와 rs를 베이스 레지스터 라고 하고 rt는 소스도 될수잇고 데스티네이션이 도리수잇고,어드레스는 상수값이다. 

### MIPS Addressing Modes
- conditional branch 의 대표적인 에제는 BEQ R1 R2 Loop, 이런건데, BEQ = branch equal이고, 이 명령어는 r1과r2의 값이 같으면 loop로 점프하라는 명령어이다. BLT, (branch less than) 등도 잇다.r1 < r2 , 이런것이 컴디셔널 브랜치이다. 그러면 이런 컨디ㅕ널 브랜치에도 레지스터 오퍼랜드가 2개가 필요한데, loop는 이 loop의 주소인데, 일단 먼저 비교를하면, rs, rt에 R1,R2가 들어ㅏㄱ면 되고 이 loop에는 , -1, 1, 6 이런값들이 들어가는데 이게 뭐냐면 바로, beq를 기준으로 ( 즉, 현재 명령어 기준으로) 그 전 몇번쨰 명령어 혹은 그 후 몇번쨰 명령어 인지를 알려주는 값이 들어간다. 현재 명령어의 주소가 pc가 가리키니까 이 loop를 pc relative addressing 이라고 한다. 즉, 현재의 프로그램 카운터가 가리키는 주소로 부터 앞, 혹은 뒤 몇번째 주소인지를 결정해준다
- base addressing에 대해 자세히 말하자면, 예를들어, 베이스 레지스터에 만약에 1000이 들어있다면, 메모리는 0번부터 2^32-1번지 까지(가상메모리: 즉, 프로그램이 저장되어잇는 메모리공간인데)그러면, 1000번이라는것은 이 가상메모리안에 어디 1000번이라는 것이 있을텐데, 그리고 이 1000번에 한 바이트의 데이터가 들어잇을텐데, 이 1000번에 a(0)가 들어잇는것이다. 그니까, 이 a(0)=1000 이라는것은, 이값이 base가 되는것이고 (인티저) 만약 1100주소를 가리키려면 이 a(25)=1100이 되는것이다. (4바이트 씩이니까 ) 그러면, 예를들어 여기서 ldw $s0, 100($s1)이라고 한다면, ldw는 load word이고, 이것은, s1이라는 레지스터 주소는 모르지만, 여기서 100을 더한 곳의 주소로부터 word이니까 4바이트를 읽어서 s0에 저장하라는 것이다. s0는 mips에서 16번 레지스터를 가리키는 또다른 명칭이다. 이 s1번의 레지스터에다가 100을 더한 주소 즉, a(25) = 1100에서, word니까 4바이트, 1100, 1101, 1102, 1103  이 4바이트를 읽어서 s0에 저장한다는것이다.(32비트가 1word니까, 레지스터는 32비트면 최대로 저장하는것이다.) 그러면 이제 읽어오는데, 근데 여기서 1100번 바이트가 Lsb가 될지, 혹은 1103번 바이트가 lsb가 될지는 회사마다 다 다른데, x86은 little endian이고 x86은 lsb가 1100번지에 저장된다. ibm계열은 msb부터 먼저 저장한다. (big endian) 이 둘의 데이터를 저장하는 방식에 차이가 잇고, 호환을 위해서 서로 변환을 해줘야한다. 즉, 메모리 주소를 lsb부터 저장할것인지 msb부터 저장할것인지를 lsb는 little endian , msb는 big endian 이라고한다. 
- pc relative-addressiong은 예를들어 beq $s0, $s1, L1이라면, s0와 s1이 같으면 L1이 가리키는 곳으로 branch하는것이고 같지 않으면, 다음 명령어를 실행하는것이다. 그래서 s0가 rs, s1이 rt에 해당하는것이고, L1은 백워드 브랜치면 마이너스도 될수잇고 포워드브랜치면 플러스도 될수잇다. 이것은 pc 렐러티브 어드레싱이라고한다.
- immedaate addressingd은 예를들어 add immediate $t1, $t2, 3이라고 한다면 예를들어, 어떤 레지스터에 잇는 값에다가 3혹은 10같은 조그만constant를 더하고싶은데, 만약에 저런 immedate addreesing이 없으면, 이 상수를 정의해주고, 메모리에 저장하고 읽어온다음 더해야하는데 이 방법을 사용하면 immediate value 즉, shift amount에 이 3, 10 값을 저장해두고 이 값을 사용하면 된다. 5비트니까 0~31까지 표현할수잇고 혹은 -16~15까지 표현할수잇다. 즉, 이 방법은 작은 상수값을 계산할때 편하다. 즉, 위의 명령어는 add immediate이면, 2번쨰 소스에는 실제로 레지스터 오퍼랜드가 아니라 이미디엣 오퍼랜드에서 가져와라는 것이다. 즉 t2에 3을 더해서 t1에 저장하라는것이다.t2,t1은 s2,s1과 마찬가지로 실제로는 physical rsgister에 매핑된 레지스ㅓㅌ이다. 즉, 하드코딩된 데이터 연산을 하는것이다.
- register addressing 이란 뭐냐 예를들어 jr $ra가 있는데, 이것도 결국 명령어에 대한 어드레싱 모드이다. Jr은 리턴에 해당하는 명령어인데, $ra라는것은 return adrress regsiterd인데 retrun adress register라는것은 뭐냐면, 우리가, main이라는 코드에서 실행하다가 점프&링크하고 팩토리알 하는데, 안에 아규먼트 레지스터를 넣고, 이 팩토리얼 코드는 어디 잇는것인데. 모든 함수의 마지막은 리턴인데, 이 리턴을 jr $ra이런식으로 표현한다는것이다. 근데 이 팩토리알 함수는 메인말고 다른곳에서도 이 팩토리얼 함수를 호출할수잇는데, 이 어떤 함수를 콜하는것을 이 예제에서는 main->fact함수를 콜한것인데. 이때 main을 caller, facf 를 callee라고한다. 점프앤링크 펙토리얼이 여기 말고도 다른곳에서도 호출할수잇는데, 이러면 caller의 위치가 막 달라진ㅈ다. 즉, 이 함수를 콜한곳에서 리턴한곳은 이 e다음 명령어로 와야하는데 이 때 부르는 곳의 장소를 callsite 라고한다. 이 위치에 따라서 리턴할 어드레스가 달라진짣. 그래서 점프앤링크, 즉 jal 명령어가 뭐냐면 아까 배운 점프명령어랑 똑같은데, Opcode만 다를뿐이다. 이 jal도 26비트 수도디렉토리 어드레스로 바로 점프하는ㅁ ㅕㅇ령어이다. 하지만, 펑션콜은 일반 점프와는 달리 반환할 장소를 기억하고잇어야한다. 그래서 jal a명령어는 jump명령어랑 다 똑같은데 여기서, return adrress  registe에다가 +4(4바이트, 명령어는 32비트니까)를 해주는 것이다. 즉, 현재의 갑싱 pc라면, 돌아올곳의 주소를 리턴 어드레스 레지스터에다가 저장하고가야한다. 그래야만 리턴할떄 리턴어드레스 레지스터의 내용을 보고 알맞읒 위치로 돌아올수잇다. 이 리턴 어드레스 레지스터는 31번 레지스터이고 이것은 항상 리턴어드레스 레지스터이다. 이것을 어셈블리 언어에서는 $ra라고 부른다. 그러면, jal은 점프명령어인데, 돌아갈 곳을 리턴어드레시 레지스터에 있는 값으로 점프하는것이다. 이떄 주소값이 변하지 않는것ㅇㄹ direct branch이라고 한다 예를들어, psedo dircet addressing(j L1)이나 혹은 pc-relative (beq $s0 $s1 L1) 같이 점프할곳의 주소가 변하지 않는것을 direct branch라고 하고 register addressing같이 레지스터의 값에 따라서 돌아갈 곳이 변하는것, 즉 어디로 갈지 모르는것을 indirect branch 라고한다.
- Pseudodirect adressing은 뭐냐면, 아까 conditional branch에서는 pc가 가르키는 현재 명령어가 있는 주소를 기준으로 -2^15 혹은 +2^15 뿐이 못가는데, 이 psue는 j-type이라는 명령어를 사용하는데, 여기에는 jump 혹은 점프앤링크 같은게 잇는데 점프앤링큰느 프로시저콜, 즉 펑션콜에 해당하는 명령인데 어떤 함수 호긍ㄴ 어떤 주소로 바로 점프하라는것이다. 즉 go to와 같은것이고 이것은 Op코드만 잇으면 되니가 26비트 offset을 다 쓸수잇닫는것이다. 여기서 가상 메모리가 잇는데 만약 32비트 시스템 mips이면, 이 가상메모리는 최대 2기가이다. 나머지 2기가는 커널이 가지고잇는것이다. 그래서 이제 이 가상메모리는 프로그램이 저장되어잇는 영역인데 프로그램은 유저 코드와 커널코드가 같이 들어가 잇는것이다. 가상메모리에 텍스트라는 것은 첫번쨰 명령어가 텍스트부터 시작하는것이고 이 텍스트영역의 끝까지 잇다. 텍스트 영역은 우리가 짠 코드들이 저장되어잇는것이고, data영역은 static 으로 선언된 변수 혹은 전역변수가 저장되고, dynamic data는 heap영역 이고 stack은 스택영역, 즉 함수 호출떄 함수만 사용하는 로컬데이터 영역이다. 즉 텍스트영역에서 실제로 명령어가 저저ㅏㅇ되는것ㅅ이고 이것을 잘 살펴보면 사실 코드는 작고 데이트가 호ㅝㄹ씬 크다는건데, 텍스트에 명령어들이 저장되어잇는데 예를들어 ㅡmips 32비트 시스템이라고하면, 헥사로 나타냇을떄 텍스트영역은 0040 0000 에서 1000 0000 까지이다. 즉, pc는 이사이에서만 왔다갓다 한다는것이다. 명령어니까, 명령어는 4바이트(32비트, 앞에서 배운 명령어들이 이텍스트영역에 저장, opcode랑 햇갈리지말기)이니까 그리고, 앞에서 배운 모든 데이터와 명령어는 메모리에 저장되어잇는건데 4바이트 짜리 명령어는 이 명령어는 즉, 4바이트니까 4의 배수로만 저장된다 0, 4 , 8 ,12 ,.. 그래서 가장 앞에 2비트는 전부 00이다. 0,4,8이니까 이진수로는 다 00, 100 이런식이다. 그니까 모든 명령어의 주소는 결국 msb는 0000(2진ㅇ수) lsb 2비트는 00이다. 그러면, 이제 앞에 4비트는 필요업속 뒤에 2비트 필요없으니까 결국 26비트면 텍스트영역의 명령어를 모두 표현할수잇다는것이다. 그래서 26비트가address이다. 그래서 이것을 수도direct 어드레싱이다. 26비트이지만 사실은 32비트 명령어를 모두 커버할수잇다는것이다. 결국, 수도디렉트 어드렣싱은 바로 26비트 명령어의 주소가 잇는곳으로 바로 점프할수잇느는것이다 !
- 예제

### 4. Procedure Call & Return
- 이제 덧셈,뺄셈,곱셈,나눗셈,control transfer, data transfer 에 대해 다 배ㅜ었고 이제 나머지는 function call,procedure call, retrun 이다. 프로시져 펑션 콜할때는 어떤일이 벌어지냐면, 우리가 프로시져나 펑션콜할때는 파라미터를 전달해줘야하는데 (아규먼트) 아규먼트들을 전달해주려면 caller가 callee 한테 어떤 무언가를 통해서 전달해줘야한느데 메모리를 통해서 전달해주려면 메모리로부터 로드해야하니까 오버헤드가 크니까 레지스터를 통해서 전달해주는데, 특정 레지스터는 misassemble해서 아규먼트 래지스터로만 사용하는 레지스터들이 있는데, 얘를 $a0~$a3 (4개쓰면, 아규먼트가 더 많으면 더 많이  필요한만큼 쓰면된다)  그래서, 콜리가 억세스할 수 잇는곳에 (보통 레지스터)에 다가 파라미터를 집어넣어 준다. 그래서 아까 팩토리얼 함수를 콜하렴녀 fact(5)를하려면 a0에다가 5를 집어넣어줘야한다. 그래서 뭔가 그전에 연산을 통해서 a0에다가 5를 집어넣고 fact(5)함수를 콜하는것이다. 아규먼트가 여러개여도 a0~a3에 차례로 아규먼트를 전달해주면되고 콜리는 콜러가 보내준대로 그 레지스터에서 읽어오면 되는것이다. 아규먼트를 전달한 다음에 그다음에 점프앤링크를 해야한다. 이게 펑션콜이다. 그다음에 점프앤링크를 하고 콜리의 주소를 준다.그럼 이게 이 콜리가 팩토리알이면, 팩토리얼로 psedo dirce로 바로 점프하면서 돌아올 값(pc+4)을 주소를 $ra에 저장하는것이다. 즉 , 2가지 일을 한번에 하는것이다. 
- 그 다음에는 ,이제부터는 callee 즉, fact함수가 실행하는것이다. 이 fact함수가 실행하면 처음에 할 일은 callee가 사용할, 즉 callee에 필요한 저장장소를 allocation해야한다. 자료구조에서 스택을 배ㅝㅅ는데 컴퓨터구조에서의 스택은 가상메모리 안에서의 스택이다. 즉 시스템스택. 그래서, 우리가 프로그램이 사용하는 데이터ㄴ는 크게 static data와 dyanamic data 둘로 나뉠수 잇는데 static data라는것은 프로그램 실행중에 항상 자기 저장 장소를 가지고 있는 주소이다. 항상 자기 장소를 가지고잇다. dynamic data는 임시로 사용했다가 사용이 끝나면 반환하는것이다. 이 dynamci data는 heap, stack 두 가지가 잇는데 힙이라는것은 우리가 그떄그떄 프로그램 도중에 malloc에서 요청한 만큼 allocation하고 사용이 다 끝나면 free로 반환하는것이다. 스택은 어떤 함수를 안에 변수들인데, 이 변수들은 범위가 이 함수 안에서만 사용하는 변수들이고 함수 바깥에는 보이지 않는다. 이런 데이터를 스택이라고한다.
- 이제는 mips 에서 어떤 절차로 함수가 호출되는지를 알아보자. 어떤 main이라는 펑션에서 어떤 함수를 호출할떄, main이 caller가 된다. main에서 factrial이라는 함수를 점프앤링크를 통해서 호출하게 되면, main은 caller, factorial은 callee가 된다. 이 두 함수사이에는 콜리 펑션이 파라미터에따라서 다른작업을 하기때문에 파라미터를 전달해줘야ㅏㄴ다. 그래서 파라미터 전달을 하기위해서 먼저 콜러가 콜리가 액세스 할수잇는곳에 파라미터를 레지스터를 이용해서 아규먼트들을 전닿ㄹ한다. mips의 경우 a0~a3는 이 4개ㅡ이 레지스터는 실제 4~7번의 레지스터들인데 이것들이 아규먼트를 전달할떄 쓰는 레지스터고, 추가로 필요하면 다른 레지스터를 이용해서 더 사용한다. 즉, 먼저 아규먼트를 아규먼트레지스터에 올려논다음에 그다음에 펑션콜을 한다. 펑션콜에 해당하는 밉스 명령어는 jal(점프앤링크)이다. jal은 j명령어랑 거의같다. 점프명령어는 수도디렉트 모드, 점프앤링크는 점프를 수행하면서 동시에 추가적인 작업을 하는 명령어이다. 즉 펑션콜은 fact함수를 다 실행하고 그다음 다 실행하면 리턴명령을 하는데, 이 리턴명령어가 jr $ra이다. jr $ra는 리턴어드레스 레지스터의 내용으로 다시 돌아가라는것ㅇ디ㅏ. 그래서 jal는 점프해서 fact함수로 간다음, $ra <- PC+4를 저장하는것이다. 그래서 이런 명령어 즉, 돌아올곳의 주소를 알려주고 점프한다. 이 명령어를 점프앤링크라고 부르고 다른 머신아키텍처는 그냥 콜이라고도 한다. jal를 실행하는 순간 상태는 main에서 fact로 바뀌는것이고, fact안에서 즉, 콜리를 이제부터 실행하는것이다. 그럼 이제 콜리에서 가장 먼저 하는것은 콜리에서 사용하는 로컬변수들을 저장할수잇는 메모리안에 저장공간을 만드는것이다. 왜냐면, 우리가 어떤 함수내에 선언된변수들은 그 함수안에서만 볼수잇는데, 이런것들을 로컬변수라고한다. 그럼 이런 로컬변수들을 글로벌 변수랑 같이 저장해두면, 이 로컬변수들은 함수를 실행할때만 억세스하는 변수인데, 그럼 안사용할때가 만흥ㄴ데 계속 자리를 차지하면 메모리 공간의 낭비가 되니까 이 로컬변수는 이 함수가 실행될때만 메모리에 할당했다가 함수가 리턴이되면 메모리를 다시 반환하도록 되어잇다. 그래서 이 스택은 함수마다 자기가 사용할 로컬벼ㄴ수를 저장할 공간이다. 즉, 함수가 실행될떄만 사용하고 함수가끝나면 다시반환하는. 얘를 스택이라고하고 메모리안에있는 스택을 시스템스택이라고한다.  그래ㅓㅅ 콜리에서 로컬공간에 필요하 ㄴ로컬변수들을 할당하고, 스택포인트를 기준으로 함수내에서 사용하는 변수나 이런것들을 저장해둔다. 그래서 스택프레임은 이 함수에만 국한된 공간이고, 각 함수마다 자신이 가즌 공간이다. 펑션콜이되면, 스택프레임이 하나씩 할당된다. 프로시저와 펑션을 엄밀하게 구분하면 프로시저는 리턴값이 없는것 펑션은 잇는것ㄱ,이제 콜리가 다 마치고 반한될떄 리턴값이 잇으면 콜러가 액세스할수잇는곳으로 반환값을 알려줘야한느데 이 것도 마찬가지로 레지스터로 전달해준다. 이 리턴값을 전달하는 레지스터가 $v0, $v1이다. 왜 2개를쓰냐면 결과값이 부동소수점, 인 경우이면 8바이트 실수(double precision)이니까 이떄는레지스터 하나가지고 안되니까 2개를써서 리턴한다. 즉, 단순히 정수만 리턴하려면 v0만쓰면되고 실수이면 v0,v1에다가 결과를 저장해두고 리턴함ㄴ된다. v0,v1은 레지스터 번호로 2,3번이다. 0번레지스터는 항상 읽기만 하는 레지스터이다. 그래서 다시 절차를밝아보면 이제 리턴값을 result value register에 저장한다음에는 이제 다시 jal명령어의 다음 명령어로 돌아가야한다. 다음명령어의 주소는 jal +4 이다. 즉, 이것을 다시보자면, 먼저 jal fact로 fact함수를 콜하기전에 jal 명령어로 fact를 호출하는데, jal 명령어는 fact를 콜 하기전에 먼저, argument register $a0 ~ $a3에다가 아규먼트들을 저장해주고 귿 ㅏ음, $ra <- pc+4를 하고 이제 callee, 즉 fact함수는 $a0~$a3에 잇는 매개변수에 액세스하여 함수를 실행하는데 이떄 함수 내의 로컬 스택프레임 공간안에 이 매개변수를 메모리할당한다. 그 후 이 함수를 다 마치면 리턴하기 전에 $v0,$v1에다가 리턴값을 저장해주고 jr $ra로 아까 저장해두엇던 돌아갈 공간으로 돌아가게도니다. 스택에 대해서 좀 알아보면, 각 함수마다 사용할 자신의 공간이 스택프레임이다. 그럼 이 스택에는 어떤 변수가 저장된다면, 함수안에 선언된 모든로컬변수들이 저장되고 또 매개변수, 리턴어드레스 등이 저장된다.왜냐면, 이게 $a0~$a3에 매개변수를 쓰고 자기 스택에 이 매개변수를 저장하지않으면, 이 함수에서 또 함수를 콜할때 $a0~$a3가 덮어쓰여지게되기때문에 스택에 자기 아규먼트값을 저장해주어야한다. (리턴어드레스레지스터도 마찬가지이다), 그래서 어떤 함수안에서 또다른 프로시저 콜할떄마다 이 아규먼트레지스터,리턴어드레스레지스터가 변경되기떄문에 변경되기전의 갑승ㄹ 스택에 저장하고 다시 그 펑션 에서 돌아와서는 스택으로부터 원래의 값을 복구하는 작업을한다. 그다음에 saved registe는 이제 펑션, main에서 a를 콜하고 a에서 b를 콜하고 b에서 c를콜하고 어떤 일이 일어나도 각 프로시저에서는 레지스터들을 사용하느데 그니ㅏㄲ, 이 레지스터들을 가지고 연산을하는데 그러면 내가 main에서 a를 콜한다음에 a에서 b를 콜하는데 b에서 a로 돌아올때는 어떤게 다 지워졋는지모른다 (b에서 연산을 하느라 레지스터들을 막 사용햇기떄문에) 그래서, 자기가 잇는 레지스터중에 일부 즉, 자기가 펑션콜을 한 다음에 돌아와서도 어떤 값을 유지하고 싶은 그런 레지스터 값들은 스택에 저장해두고 복귀할때 이 스택에서 레지스터들을 복구해야한다. 즉, savd regsiter란, 만약에 어떤 레지스턷ㄹ은 값이 없어지던 말든 신경안쓰는 레지스터도 잇겟지만 값을 꼭 알아야할 레지스터들은   스택에 저장해둿다가 다시 복구해야한다. 그래서 16~23번까지는 saved register로, 펑션콜할때마다 보존해야할 것들은 이 16~23번 레지스터에 저장해두고 함수가 호출되고 하면 스택에 이 레지스터 안의 값들을 보존해두고 8-15번 temporary register들은 한번쓰고 마는 값들이니까 굳이 저장해둘필요업다. 이것들박에도 ㅍ어션안에서의 모든 로컬변수, 스트럭쳐, 어레이들을 스택프레임에 allocation한다. 그래서 어떤 펑션을 콜하게되면 이 스택은 가상메모리에서 위에서 아래로 증가하는데, 즉, fp는 frame point는 맨 위의 탑 스텍프레임의 맨 아래공간을 말하고, sp는 스택의 가장 윗부분, 즉 맨위의 스택의 가장 윗부분을 말한다. 우리가 dram 뺴놓고는 다 항상 virtual memory이다. 프로그래머가 프로그램할때는 그냥 가상메모리만 신경쓰면된다. 내 메모리가 어디는 디램에잇고 어디는 디스크에잇고 이런거 신경안써도된다. 그냥 가상메모리(data, text, stack 이런것들)만 생각해놓으면 하드웨어나 운영체제가 알아서해주기때문에이런거 신경스지않아도된다. 즉, 하드웨어랑 운영체제가 이 프로그램들을 알아서 일부는 디스크, 일부는 램, 일부는 캐시에 이런식으로 할당하고 이것은  하드웨어와 운영체제가 알아서해주는거고 프로그래머는 항상 가상의 메모리공간을 생각하면되낟. 이 가상의메모리공간에 text는 명령어들이 저장된공간이고 나머지는 전부 데이터이다. 사실text는 얼마안된다. 이 static data는 글로벌변수, statci 변수이고ㅗ 다른 파일에서도 이 글로벌 변수를 참조할수잇다.  그러면 이 gp(글로벌포인터)도 static data 이만큼 사용하고, (그래서 글로벌변수를 배열을 엄청크게하면 static data가 초과하야 실행이안된다.) 그래서 이static data위엥는 dynamic data가 들어가는데 여기는 힙영역으로 프로그램 중간에 할당되거나 반환도거나 한다. 그래서 계속 할당되다가 중간중간에 반환되면 이 힙영역도 중간중간에 홀들이 생기는데 그래서 중간중간마다 compression을해야한다. 이 공간도 필요할때만 allocation했다가 다쓰면 deallocation하니까 효율적으로 사용할수잇는공간이다. 스택도 맟나가지이고, 이 static data공간은 항상 자리를 차지하는 permanent한 영역이다. 그래서 보통은 이 가상메모리공간이 프로그램사이즈이다. mips는 반은 유저코드, 반은 커널코드이고 x86같은경우는 1/4는 커널, 3/4는 유저 이다. 그래서 우리가 프로그램을 실행하면 우리가 코드 실행하다가 시스템콜을하거나 엑셉션이 걸릴떄마다 OS들어갔다가 유저모드 커널모드 왓다갓다 바꿔가면서 실행한다. 그래서 mips 0번은 쓸수는없고 읽기만 할수잇는 레지스터이다.

### 5. Linking
- 이제 링킹에서 배울것은 실행파일 이란 무엇인가 obj파일이란 무엇인가. obj파일도 0과1로 된 머신코드이고, 실행파일도 0과1로 된 머신코드인데 이게뭘까 그리고 윈도우에서 보면 exe는 뭐고 dll은 뭘까. 즉, 이번단원에서는 이런것에대한 의문점을 배운다.
- 우리가 c프로그램을 에디터로 짜면 이거는 그냥 텍스트(아스키)파일일 뿐이다. 이거는 기계가 전혀 이해할수없는 텍스트파일이다. 그래서 머신에서 실행하려면 머신이 이해할수 잇는 머신의 target machine instruction으로 translation을 해줘야한다. 트랜슬레이션에는 두 가지가 있는데ㅡ 하나는 컴파일러, 하나는 인터프리터이다. 인터프리터는 (번역+실행)이고 파이썬,자바등이고 컴파일러는 나머지 c 등이고 인터프리터보다 컴파일러가 컴파일할떄 더욱 다양한 작업을해서 좀더 효율적으로 기계어를 제너레이션한다. 인터프리터는 실행까지해야하기때문에 너무 많이 고려하다보면 실행시간이 늘어나기떄문에 너무 많은 작업을하지않는다.
- 컴파일러 드라이버는 컴파일레이션이 그래서 컴파일만하게되면 오브젝트 파일만 만들고 실제로는 전체 executable(즉 , 실행파일) 까지 만들려면 Linking까지 다 해야하는데 그래서 컴파일레이션 과정이 여러단계로 나눠져있는데, Complier driver라는것은 이단계들을 하나로 묶어서 편하게 해주는 툴이다. 이 드라이버가 알아서 단계단게를 알아서 처리해준다. 예를들어, gcc -o2 -v -o p m.c a.c 이라고하면, gcc는 gnu c compiler이고 이 gcc가 compiler driver이다., m.c라는 파일 2개를 컴파일해서 하나의 실행파일 p를만든다는 뜻이다. 그래서, 이 -o p 는 실행파일의 이름을 p로하라는 것이고, obj파일을 만들기 위한 소스파일이 m.c a.c이고 -v는 -verbose 옵션이라고 해서 컴파일 중간에 각 단계별로 일어나는 단계를 모두 알려달라는 뜻이다. -O2는 optimization level 2 라는 뜻이고, 우리가 처음 프로그램 짤때는 디버그 모드에서 짜는데, 이떄는 옵티마이제이션을 할 필요가 없다. 이떄는 그냥 -g 옵션으로 디버깅만 하면 되고 이제 코드가 에러가 없다는것을 알았으면 이제부터 -O 옵션을 넣어서 옵티마이제이션을 한다. 그러면 이제 컴파일 시간은 디버그모드보다 훨씬 오래걸리지만 우리가 짠 코드를 위치를 옮기거나 혹은 쉬프트연산을 한다거나 해서 최적의 코드를 생성한다. 그래서 위의 명령어를 돌리면 처음에 cpp라고 해서 이것은 c preprocess인데, 이때, #include define MACRO define Constant #으로 들어있는 이런것들ㅇ르 처리하는데, 이것들은 그냥 text substitution일 뿐이다. 인클루드는 파일 긇어오고 매크로는 텍스트 대체하는거고 이런거를 하고, 그러면 이 cpp 즉, 전처리를 끝난 파일은 아직도 역시 아스키 파일일 뿐이다. 그래서 파일 이름이 .i 로 끝나는 파일로 나온다. 그 다음에 이제, cc1이 c컴파일러인데ㅔ 이것이 만든거는 처음에는 .s로 끝나느 symbolic assembly 프로그램이다. 이거는 아까 본 어셈블리어로 된 프로그램이다. 이것도 텍스트파일이다. 아직은 머신코드가 아니다. 그다음에 as(어셈블러) 이 어셈블러가 심볼릭 파일을 컴파일해주면 이제 relocatable object file 즉, .O 로 끝나면 오브젝트 파일 하나가 생긴거다. 그래서, m.c를 해서 m.o에 해당하는 오브젝트 파일이 하나 만들어지고  a.c도 preprocessor, compile, assembler 해서 obj파일이 만들어지면, 이제 ld라고 하는 로더가 있는데 이 로더가 링커이고 이 링커가 이 두 개의 오브젝트 파일을 연결시켜 주는것이다. 그래서 서로 참조를 물음표에서 물음표를 없애주고 원래 해당하는 함수나 변수로 바꿔주고 이 것들을 이제 하나의 executable파일로 묶는것이다. 이제, 이 시스템 obj 파일은 만약에 여기서 stdlib 즉, printf 나 scanf를 사용하면 라이브러리에 있는 오브젝트 파일들을 같이 연결시키는 거다. 그럼 여기에는 이제 실행하는데 필요한 모든 코드나 데이터가 다 있는것이고 이제 이 실행파일을 p로 하라는것이다.   
- 일반적으로 과거에는 프로그램하나를 c파일하나로 다 묶었는데 (무슨함수무슨함수,..) 그래서 이 c파일하나를 컴파일하면 이게 바로실행파일이됫다 근데 이게 많이 비효율적이고, 여러사람이 작성하다보니까 또는 다른사람이 작성한것을 재사용할떄 불편해지기시작햇다. 그니까 프로그램을 크게 한 덩어리로 짜개되면 여기서 const하나만 바꿔도 다시 컴파일해야한다. 즉, 조그만한 변화도 프로그램 전체를 ㅋ다시 컴파일해야하고 또는 코드중에 잘짠 어느 함수를 다시 쓰려고하려면 이 c파일을 통쨰로 다 가져와야한다(사용하기싫은부분도) 그래서, 프로그램을 관련된 부분만 여러개의 파일을 만든다. 하지만, 이 일부분은 어디까지나 프로그램의 한 조각일뿐이다. 그래서 이걸로 실행파일은 만들수없지만 이것 자체만 컴파일할수는잇다. 그래서 이것은 프로그램의 한 조각이 되는것이고 이것은relocatable object file이라고 한다. 그래서 이 파일안에서 다른 파일에있는 펑션을 콜할수도잇고, 글로벌변수를 접근할수도잇다. 근데 아직 이것은 프로그램의 전체가 아니고 일부분일뿐이니까, 아직 이 조각에는 물음표들이있다. external reference라고 해서 자기 안에 정의되어잇지 않는 함수나 변수를 사용하게 되면 일단 물음표이다. 하지만 일단 참조관계를 갖는 것들은 다 머신코드로 번역되어잇긴 하지만 아직은 전체가 아니고 일부 조각일뿐이다. 그래서 이런것을 relocatable obj file이다. 그래서 실행파일을 만들려면 이 오브젝트 파일들이 모두 연결되야한다. 이걸 연결하는것을 Linker라고한다. 이 obj파일안에서 얘가 참조하는 글로벌변수가 다른 obj파일안의 이 변수이구나 니가 부른 함수가 이 파일의 이 함수이구나 라는걸 여기서 알게되고 여기서 이제 프로그램의 전체가 되고, 이게 실행파일이 되는것이다. 그다음에 우리가 작성한 파일뿐아니라 라이브러라 파일도 일부연결될수잇다. 그래서 이런식으로 seperate compliation이라고 한다. 그래서 어떤 함수를 사용할떄 이 파일별로만 재사용하면된다. 그래서 우리가 stdlib나 mathlib를 사용할떄 이 라이브러리 전체가 다 오는것이아니고 우리가 실제로 사용한그 파일만 불러오는것이다. printf, mathfuction등 이 파일들만 내가 사용한 부분만 링커된다.
- Obj파일은 3가지로 나뉨
- executable object file은 디스크안에 있는 파일이고, 이 파일안에는 (링커에의해생성) 가상메모리가 있고, 이게 실행되면 이제 이 가상메모리에 있는 내용을 카피한다. physical memory는 하드웨어와 운영체제가 결정한다. 우리는 (프로그래머는) 이 프로그램이 디스크에 저장되는지 메모리에저장되는지 캐시에저장되는지는 신경쓰지않는다. 그냥 가상메모리만 신경쓰면 되는거다. physical address는 DRAM의 주소, 즉, 일단 프로그램은 가상메모리에 있고, 실제로 OS가 이것을 보고 실제 디램에 카피하는것이다.
- linker는 static linker, dynamic linker 2개가 있는데 static은 컴파일타임에 링킹하는거고 dynamic은 런타임에 필요에따라 링킹할수있는것 DLL파일이 dynamic linking library. 이 dll파일이 실제로 실행중에 연결될 수가 있음
- 모든 OS의 전신은 UNIX. (Windows는 뭐지?)
- 글로벌변수는 함수 바깥에 선언된 변수이고, 링킹된 모든 파일에서 액세스할수잇는 변수이다. 로컬변수는 함수 안에 선언된변수
- static은 File scope
- static local variable은 static data영역에 assign되어있음. static local variable은 scope는 이 함수 안에라서 다른 곳에서는 못사용하는데, life는 static이라서 함수가 끝나고 값을 계속 유지하고있음. 그래서 이 함수를 호출할때마다 이 값은 계속 예전값을 잃어ㅓ버리지 않고 기억하고있음
- 그럼이제, static variables는 static local variables랑 다른건데, 이건 뭐냐면 static variables는 global variables랑 똑같이 static data 영역에 할당되지만, 글로벌변수가 링킹된 모든 파일에서 액세스 가능하다면 static 변수는 이 파일 안에서만 액세스 가능하다. 즉, file scope 또는 module scope, module 이란 그 파일을 의미
- 링커가 관심있는 것은 함수와 모든 글로벌, static 변수들. dynamic data는 런타임에 정해지므로 링커는 관심없음
- 함수들은 기본적으로 file scope